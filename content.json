{"meta":{"title":"若邪","subtitle":null,"description":null,"author":"若邪","url":"https://jaycewu.site"},"pages":[{"title":"","date":"2019-05-15T16:05:35.708Z","updated":"2019-05-15T16:05:35.708Z","comments":false,"path":"categories/index.html","permalink":"https://jaycewu.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-15T16:05:35.708Z","updated":"2019-05-15T16:05:35.708Z","comments":false,"path":"tags/index.html","permalink":"https://jaycewu.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 Node.js 写一个代码生成器","slug":"使用 Node.js 写一个代码生成器","date":"2019-05-09T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2019/05/09/使用 Node.js 写一个代码生成器/","link":"","permalink":"https://jaycewu.site/2019/05/09/使用 Node.js 写一个代码生成器/","excerpt":"","text":"原理代码生成器的原理就是：数据 + 模板 =&gt; 文件。数据一般为数据库的表字段结构。模板的语法与使用的模板引擎有关。使用模板引擎将数据和模板进行编译，编译后的内容输出到文件中就得到了一份代码文件。功能因为这个代码生成器是要集成到一个小工具 lazy-mock 内，这个工具的主要功能是启动一个 mock server 服务，包含curd功能，并且支持数据的持久化，文件变化的时候自动重启服务以最新的代码提供 api mock 服务。代码生成器的功能就是根据配置的数据和模板，编译后将内容输出到指定的目录文件中。因为添加了新的文件，mock server 服务会自动重启。还要支持模板的定制与开发，以及使用 CLI 安装模板。可以开发前端项目的模板，直接将编译后的内容输出到前端项目的相关目录下，webpack 的热更新功能也会起作用。模板引擎模板引擎使用的是 nunjucks。lazy-mock 使用的构建工具是 gulp，使用 gulp-nodemon 实现 mock-server 服务的自动重启。所以这里使用 gulp-nunjucks-render 配合 gulp 的构建流程。代码生成编写一个 gulp task ：1234567891011121314151617181920212223242526const rename = require('gulp-rename')const nunjucksRender = require('gulp-nunjucks-render')const codeGenerate = require('./templates/generate')const ServerFullPath = require('./package.json').ServerFullPath; //mock -server项目的绝对路径const FrontendFullPath = require('./package.json').FrontendFullPath; //前端项目的绝对路径const nunjucksRenderConfig = &#123; path: 'templates/server', envOptions: &#123; tags: &#123; blockStart: '&lt;%', blockEnd: '%&gt;', variableStart: '&lt;$', variableEnd: '$&gt;', commentStart: '&lt;#', commentEnd: '#&gt;' &#125;, &#125;, ext: '.js', //以上是 nunjucks 的配置 ServerFullPath, FrontendFullPath&#125;gulp.task('code', function () &#123; require('events').EventEmitter.defaultMaxListeners = 0 return codeGenerate(gulp, nunjucksRender, rename, nunjucksRenderConfig)&#125;);代码具体结构细节可以打开 lazy-mock 进行参照为了支持模板的开发，以及更灵活的配置，我将代码生成的逻辑全都放在模板目录中。templates 是存放模板以及数据配置的目录。结构如下：只生成 lazy-mock 代码的模板中 ：generate.js的内容如下：12345678910111213141516171819202122232425262728293031323334353637const path = require('path')const CodeGenerateConfig = require('./config').default;const Model = CodeGenerateConfig.model;module.exports = function generate(gulp, nunjucksRender, rename, nunjucksRenderConfig) &#123; nunjucksRenderConfig.data = &#123; model: CodeGenerateConfig.model, config: CodeGenerateConfig.config &#125; const ServerProjectRootPath = nunjucksRenderConfig.ServerFullPath; //server const serverTemplatePath = 'templates/server/' gulp.src(`$&#123;serverTemplatePath&#125;controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath)); gulp.src(`$&#123;serverTemplatePath&#125;service.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Service.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ServiceRelativePath)); gulp.src(`$&#123;serverTemplatePath&#125;model.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Model.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ModelRelativePath)); gulp.src(`$&#123;serverTemplatePath&#125;db.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '_db.json')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.DBRelativePath)); return gulp.src(`$&#123;serverTemplatePath&#125;route.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Route.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.RouteRelativePath));&#125;类似：1234gulp.src(`$&#123;serverTemplatePath&#125;controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath));表示使用 controller.njk 作为模板，nunjucksRenderConfig作为数据（模板内可以获取到 nunjucksRenderConfig 属性 data 上的数据）。编译后进行文件重命名，并保存到指定目录下。model.js 的内容如下：123456789101112131415161718192021222324252627282930313233343536373839var shortid = require('shortid')var Mock = require('mockjs')var Random = Mock.Random//必须包含字段idexport default &#123; name: \"book\", Name: \"Book\", properties: [ &#123; key: \"id\", title: \"id\" &#125;, &#123; key: \"name\", title: \"书名\" &#125;, &#123; key: \"author\", title: \"作者\" &#125;, &#123; key: \"press\", title: \"出版社\" &#125; ], buildMockData: function () &#123;//不需要生成设为false let data = [] for (let i = 0; i &lt; 100; i++) &#123; data.push(&#123; id: shortid.generate(), name: Random.cword(5, 7), author: Random.cname(), press: Random.cword(5, 7) &#125;) &#125; return data &#125;&#125;模板中使用最多的就是这个数据，也是生成新代码需要配置的地方，比如这里配置的是 book ，生成的就是关于 book 的curd 的 mock 服务。要生成别的，修改后执行生成命令即可。buildMockData 函数的作用是生成 mock 服务需要的随机数据，在 db.njk 模板中会使用：123&#123; &quot;&lt;$ model.name $&gt;&quot;:&lt;% if model.buildMockData %&gt;&lt;$ model.buildMockData()|dump|safe $&gt;&lt;% else %&gt;[]&lt;% endif %&gt;&#125;这也是 nunjucks 如何在模板中执行函数config.js 的内容如下：12345678export default &#123; //server RouteRelativePath: '/src/routes/', ControllerRelativePath: '/src/controllers/', ServiceRelativePath: '/src/services/', ModelRelativePath: '/src/models/', DBRelativePath: '/src/db/'&#125;配置相应的模板编译后保存的位置。config/index.js 的内容如下：123456import model from './model';import config from './config';export default &#123; model, config&#125;针对 lazy-mock 的代码生成的功能就已经完成了，要实现模板的定制直接修改模板文件即可，比如要修改 mock server 服务 api 的接口定义，直接修改 route.njk 文件：12345678910111213import KoaRouter from 'koa-router'import controllers from '../controllers/index.js'import PermissionCheck from '../middleware/PermissionCheck'const router = new KoaRouter()router .get('/&lt;$ model.name $&gt;/paged', controllers.&lt;$model.name $&gt;.get&lt;$ model.Name $&gt;PagedList) .get('/&lt;$ model.name $&gt;/:id', controllers.&lt;$ model.name $&gt;.get&lt;$ model.Name $&gt;) .del('/&lt;$ model.name $&gt;/del', controllers.&lt;$ model.name $&gt;.del&lt;$ model.Name $&gt;) .del('/&lt;$ model.name $&gt;/batchdel', controllers.&lt;$ model.name $&gt;.del&lt;$ model.Name $&gt;s) .post('/&lt;$ model.name $&gt;/save', controllers.&lt;$ model.name $&gt;.save&lt;$ model.Name $&gt;)module.exports = router模板开发与安装不同的项目，代码结构是不一样的，每次直接修改模板文件会很麻烦。需要提供这样的功能：针对不同的项目开发一套独立的模板，支持模板的安装。代码生成的相关逻辑都在模板目录的文件中，模板开发没有什么规则限制，只要保证目录名为 templates，generate.js中导出generate函数即可。模板的安装原理就是将模板目录中的文件全部覆盖掉即可。不过具体的安装分为本地安装与在线安装。之前已经说了，这个代码生成器是集成在 lazy-mock 中的，我的做法是在初始化一个新 lazy-mock 项目的时候，指定使用相应的模板进行初始化，也就是安装相应的模板。使用 Node.js 写了一个 CLI 工具 lazy-mock-cli，已发到 npm ，其功能包含下载指定的远程模板来初始化新的 lazy-mock 项目。代码参考（ copy ）了 vue-cli2。代码不难，说下某些关键点。安装 CLI 工具：1npm install lazy-mock -g使用模板初始化项目：1lazy-mock init d2-admin-pm my-projectd2-admin-pm 是我为一个前端项目已经写好的一个模板。init 命令调用的是 lazy-mock-init.js 中的逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#!/usr/bin/env nodeconst download = require('download-git-repo')const program = require('commander')const ora = require('ora')const exists = require('fs').existsSyncconst rm = require('rimraf').syncconst path = require('path')const chalk = require('chalk')const inquirer = require('inquirer')const home = require('user-home')const fse = require('fs-extra')const tildify = require('tildify')const cliSpinners = require('cli-spinners');const logger = require('../lib/logger')const localPath = require('../lib/local-path')const isLocalPath = localPath.isLocalPathconst getTemplatePath = localPath.getTemplatePathprogram.usage('&lt;template-name&gt; [project-name]') .option('-c, --clone', 'use git clone') .option('--offline', 'use cached template')program.on('--help', () =&gt; &#123; console.log(' Examples:') console.log() console.log(chalk.gray(' # create a new project with an official template')) console.log(' $ lazy-mock init d2-admin-pm my-project') console.log() console.log(chalk.gray(' # create a new project straight from a github template')) console.log(' $ vue init username/repo my-project') console.log()&#125;)function help() &#123; program.parse(process.argv) if (program.args.length &lt; 1) return program.help()&#125;help()//模板let template = program.args[0]//判断是否使用官方模板const hasSlash = template.indexOf('/') &gt; -1//项目名称const rawName = program.args[1]//在当前文件下创建const inPlace = !rawName || rawName === '.'//项目名称const name = inPlace ? path.relative('../', process.cwd()) : rawName//创建项目完整目标位置const to = path.resolve(rawName || '.')const clone = program.clone || false//缓存位置const serverTmp = path.join(home, '.lazy-mock', 'sever')const tmp = path.join(home, '.lazy-mock', 'templates', template.replace(/[\\/:]/g, '-'))if (program.offline) &#123; console.log(`&gt; Use cached template at $&#123;chalk.yellow(tildify(tmp))&#125;`) template = tmp&#125;//判断是否当前目录下初始化或者覆盖已有目录if (inPlace || exists(to)) &#123; inquirer.prompt([&#123; type: 'confirm', message: inPlace ? 'Generate project in current directory?' : 'Target directory exists. Continue?', name: 'ok' &#125;]).then(answers =&gt; &#123; if (answers.ok) &#123; run() &#125; &#125;).catch(logger.fatal)&#125; else &#123; run()&#125;function run() &#123; //使用本地缓存 if (isLocalPath(template)) &#123; const templatePath = getTemplatePath(template) if (exists(templatePath)) &#123; generate(name, templatePath, to, err =&gt; &#123; if (err) logger.fatal(err) console.log() logger.success('Generated \"%s\"', name) &#125;) &#125; else &#123; logger.fatal('Local template \"%s\" not found.', template) &#125; &#125; else &#123; if (!hasSlash) &#123; //使用官方模板 const officialTemplate = 'lazy-mock-templates/' + template downloadAndGenerate(officialTemplate) &#125; else &#123; downloadAndGenerate(template) &#125; &#125;&#125;function downloadAndGenerate(template) &#123; downloadServer(() =&gt; &#123; downloadTemplate(template) &#125;)&#125;function downloadServer(done) &#123; const spinner = ora('downloading server') spinner.spinner = cliSpinners.bouncingBall spinner.start() if (exists(serverTmp)) rm(serverTmp) download('wjkang/lazy-mock', serverTmp, &#123; clone &#125;, err =&gt; &#123; spinner.stop() if (err) logger.fatal('Failed to download server ' + template + ': ' + err.message.trim()) done() &#125;)&#125;function downloadTemplate(template) &#123; const spinner = ora('downloading template') spinner.spinner = cliSpinners.bouncingBall spinner.start() if (exists(tmp)) rm(tmp) download(template, tmp, &#123; clone &#125;, err =&gt; &#123; spinner.stop() if (err) logger.fatal('Failed to download template ' + template + ': ' + err.message.trim()) generate(name, tmp, to, err =&gt; &#123; if (err) logger.fatal(err) console.log() logger.success('Generated \"%s\"', name) &#125;) &#125;)&#125;function generate(name, src, dest, done) &#123; try &#123; fse.removeSync(path.join(serverTmp, 'templates')) const packageObj = fse.readJsonSync(path.join(serverTmp, 'package.json')) packageObj.name = name packageObj.author = \"\" packageObj.description = \"\" packageObj.ServerFullPath = path.join(dest) packageObj.FrontendFullPath = path.join(dest, \"front-page\") fse.writeJsonSync(path.join(serverTmp, 'package.json'), packageObj, &#123; spaces: 2 &#125;) fse.copySync(serverTmp, dest) fse.copySync(path.join(src, 'templates'), path.join(dest, 'templates')) &#125; catch (err) &#123; done(err) return &#125; done()&#125;判断了是使用本地缓存的模板还是拉取最新的模板，拉取线上模板时是从官方仓库拉取还是从别的仓库拉取。一些小问题目前代码生成的相关数据并不是来源于数据库，而是在 model.js 中简单配置的，原因是我认为一个 mock server 不需要数据库，lazy-mock 确实如此。但是如果写一个正儿八经的代码生成器，那肯定是需要根据已经设计好的数据库表来生成代码的。那么就需要连接数据库，读取数据表的字段信息，比如字段名称，字段类型，字段描述等。而不同关系型数据库，读取表字段信息的 sql 是不一样的，所以还要写一堆balabala的判断。可以使用现成的工具 sequelize-auto , 把它读取的 model 数据转成我们需要的格式即可。生成前端项目代码的时候，会遇到这种情况：某个目录结构是这样的：index.js 的内容：123456789import layoutHeaderAside from '@/layout/header-aside'export default &#123; \"layoutHeaderAside\": layoutHeaderAside, \"menu\": () =&gt; import(/* webpackChunkName: \"menu\" */'@/pages/sys/menu'), \"route\": () =&gt; import(/* webpackChunkName: \"route\" */'@/pages/sys/route'), \"role\": () =&gt; import(/* webpackChunkName: \"role\" */'@/pages/sys/role'), \"user\": () =&gt; import(/* webpackChunkName: \"user\" */'@/pages/sys/user'), \"interface\": () =&gt; import(/* webpackChunkName: \"interface\" */'@/pages/sys/interface')&#125;如果添加一个 book 就需要在这里加上&quot;book&quot;: () =&gt; import(/* webpackChunkName: &quot;book&quot; */&#39;@/pages/sys/book&#39;)这一行内容也是可以通过配置模板来生成的，比如模板内容为：1&quot;&lt;$ model.name $&gt;&quot;: () =&gt; import(/* webpackChunkName: &quot;&lt;$ model.name $&gt;&quot; */&apos;@/pages&lt;$ model.module $&gt;&lt;$ model.name $&gt;&apos;)但是生成的内容怎么加到index.js中呢？第一种方法：复制粘贴第二种方法：这部分的模板为 routerMapComponent.njk ：123export default &#123; &quot;&lt;$ model.name $&gt;&quot;: () =&gt; import(/* webpackChunkName: &quot;&lt;$ model.name $&gt;&quot; */&apos;@/pages&lt;$ model.module $&gt;&lt;$ model.name $&gt;&apos;)&#125;编译后文件保存到 routerMapComponents 目录下，比如 book.js修改 index.js :12345678910111213141516const files = require.context('./', true, /\\.js$/);import layoutHeaderAside from '@/layout/header-aside'let componentMaps = &#123; \"layoutHeaderAside\": layoutHeaderAside, \"menu\": () =&gt; import(/* webpackChunkName: \"menu\" */'@/pages/sys/menu'), \"route\": () =&gt; import(/* webpackChunkName: \"route\" */'@/pages/sys/route'), \"role\": () =&gt; import(/* webpackChunkName: \"role\" */'@/pages/sys/role'), \"user\": () =&gt; import(/* webpackChunkName: \"user\" */'@/pages/sys/user'), \"interface\": () =&gt; import(/* webpackChunkName: \"interface\" */'@/pages/sys/interface'),&#125;files.keys().forEach((key) =&gt; &#123; if (key === './index.js') return Object.assign(componentMaps, files(key).default)&#125;)export default componentMaps使用了 require.context我目前也是使用了这种方法第三种方法：开发模板的时候，做特殊处理，读取原有 index.js 的内容，按行进行分割，在数组的最后一个元素之前插入新生成的内容，注意逗号的处理，将新数组内容重新写入 index.js 中，注意换行。","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jaycewu.site/tags/Node-js/"}]},{"title":"以中间件，路由，跨进程事件的姿势使用WebSocket--Node.js篇","slug":"以中间件，路由，跨进程事件的姿势使用WebSocket--Node.js篇","date":"2018-11-09T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2018/11/09/以中间件，路由，跨进程事件的姿势使用WebSocket--Node.js篇/","link":"","permalink":"https://jaycewu.site/2018/11/09/以中间件，路由，跨进程事件的姿势使用WebSocket--Node.js篇/","excerpt":"","text":"上一篇文章介绍了在浏览器端以中间件，路由，跨进程事件的姿势使用原生WebSocket。这篇文章将介绍如何使用Node.js以相同的编程模式来实现WebSocket服务端。Node.js中比较流行的两个WebSocket库分别是socket.io与ws。其中socket.io已经实现了跨进程事件，广播，群发等功能，并且服务端与浏览器端是配套的，在不支持WebSocket技术的浏览器会降级为使用ajax轮询。所以。这里选择使用相对而言较为底层或原始的ws,在其基础上实现文章标题所提到的编程模式。WS使用ws简简单单就可以启动一个WebSocket服务：1234567891011const WebSocket = require('ws');const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on('connection', function connection(ws) &#123; ws.on('message', function incoming(message) &#123; console.log('received: %s', message); &#125;); ws.send('something');&#125;);上面的wss支持的事件有connection,close,error,headers,listening,ws支持的事件有message,close,error。更多详情可以这里。中间件对ws进行封装，上面提到的事件：WSS的connection，ws的message,close,error。分别提供注册中间件的接口123456789101112131415161718192021222324252627282930313233343536373839404142class EasySocket &#123; constructor() &#123; this.connectionMiddleware = []; this.closeMiddleware = []; this.messageMiddleware = []; this.errorMiddleware = []; this.connectionFn = Promise.resolve(); this.closeFn = Promise.resolve(); this.messageFn = Promise.resolve(); this.errorFn = Promise.resolve(); &#125; connectionUse(fn, runtime) &#123; this.connectionMiddleware.push(fn); if (runtime) &#123; this.connectionFn = compose(this.connectionMiddleware); &#125; return this; &#125; closeUse(fn, runtime) &#123; this.closeMiddleware.push(fn); if (runtime) &#123; this.closeFn = compose(this.closeMiddleware); &#125; return this; &#125; messageUse(fn, runtime) &#123; this.messageMiddleware.push(fn); if (runtime) &#123; this.messageFn = compose(this.messageMiddleware); &#125; return this; &#125; errorUse(fn, runtime) &#123; this.errorMiddleware.push(fn); if (runtime) &#123; this.errorFn = compose(this.errorMiddleware); &#125; return this; &#125; &#125;通过xxxUse注册相应的中间件。 xxxMiddleware中就是相应的中间件。xxxFn是中间件通过compose处理后的结构。使用runtime参数可以在运行时注册中间件。再添加一个listen方法，处理相应的中间件并且实例化WebSocket.Server1234567891011121314151617181920212223242526272829303132listen(config) &#123; this.socket = new WebSocket.Server(config); this.connectionFn = compose(this.connectionMiddleware); this.messageFn = compose(this.messageMiddleware); this.closeFn = compose(this.closeMiddleware); this.errorFn = compose(this.errorMiddleware); this.socket.on('connection', (client, req) =&gt; &#123; let context = &#123; server: this, client, req &#125;; this.connectionFn(context).catch(error =&gt; &#123; console.log(error) &#125;); client.on('message', (message) =&gt; &#123; let req; try &#123; req = JSON.parse(message); &#125; catch (error) &#123; req = message; &#125; let messageContext = &#123; server: this, client, req &#125; this.messageFn(messageContext).catch(error =&gt; &#123; console.log(error) &#125;) &#125;); client.on('close', (code, message) =&gt; &#123; let closeContext = &#123; server: this, client, code, message &#125;; this.closeFn(closeContext).catch(error =&gt; &#123; console.log(error) &#125;) &#125;); client.on('error', (error) =&gt; &#123; let errorContext = &#123; server: this, client, error &#125;; this.errorFn(errorContext).catch(error =&gt; &#123; console.log(error) &#125;) &#125;); &#125;) &#125;使用koa-compose模块处理中间件。注意xxContext传入了哪些东西，后续定义中间件的时候都可以使用。compose的作用可看这篇文章 傻瓜式解读koa中间件处理模块koa-compose使用：12345678910111213141516171819202122232425262728293031323334353637383940414243import EasySocket from 'easy-socket-node';const config = &#123; port: 3001, perMessageDeflate: &#123; zlibDeflateOptions: &#123; // See zlib defaults. chunkSize: 1024, memLevel: 7, level: 3, &#125;, zlibInflateOptions: &#123; chunkSize: 10 * 1024 &#125;, // Other options settable: clientNoContextTakeover: true, // Defaults to negotiated value. serverNoContextTakeover: true, // Defaults to negotiated value. //clientMaxWindowBits: 10, // Defaults to negotiated value. serverMaxWindowBits: 10, // Defaults to negotiated value. // Below options specified as default values. concurrencyLimit: 10, // Limits zlib concurrency for perf. threshold: 1024, // Size (in bytes) below which messages // should not be compressed. &#125;&#125;const easySocket = new EasySocket();//使用中间件获取tokeneasySocket .connectionUse((context,next)=&gt;&#123; console.log(\"new Connected\"); let location = url.parse(context.req.url, true); let token=location.query.token; if(!token)&#123; client.send(\"invalid token\"); client.close(1003, \"invalid token\"); return; &#125; context.client.token=token; next(); &#125;);easySocket .listen(config)console.log('Now start WebSocket server on port ' + config.port + '...')使用messageUse可以注册多个处理消息的中间件，比如12345678910111213141516easySocket.messageUse((context, next) =&gt; &#123; //群聊处理中间件 if (context.req.action === 'roomChatMessage') &#123; //可以在这里持久化消息，将消息发送给其它群聊客户端 console.log(context.req); &#125; next(); &#125;) .messageUse((context, next) =&gt; &#123; //私聊处理中间件 if (context.req.action === 'privateChatMessage') &#123; //可以在这里持久化消息，将消息发送给私聊客户端 console.log(context.req); &#125; next(); &#125;)每个中间件都要判断context.req.action，而这个context.res就是浏览器端或客户端发送的数据。怎么消除这个频繁的if判断呢? 我们实现一个简单的消息处理路由。路由定义消息路由中间件messageRouteMiddleware.js12345678910export default (routes) =&gt; &#123; return async (context, next) =&gt; &#123; if (routes[context.req.action]) &#123; await routes[context.req.action](context,next); &#125; else &#123; console.log(context.req) next(); &#125; &#125;&#125;定义路由router.js123456789101112export default &#123; roomChatMessage:function(context,next)&#123; //可以在这里持久化消息，将消息发送给其它群聊客户端，以及其它业务逻辑 console.log(context.req); next(); &#125;, privateChatMessage:function(context,next)&#123; //可以在这里持久化消息，将消息发送给私聊客户端，以及其它业务逻辑 console.log(context.req); next(); &#125;&#125;使用：1easySocket.messageUse(messageRouteMiddleware(router))跨进程事件上一篇文章已经介绍了跨进程事件，这里直接说实现。使用Node的原生事件模块1234567891011121314151617181920212223242526272829303132333435363738394041import compose from './compose';const WebSocket = require('ws');var EventEmitter = require('events').EventEmitter;export default class EasySocket extends EventEmitter &#123; constructor() &#123; ... this.remoteEmitMiddleware = []; ... this.remoteEmitFn = Promise.resolve(); &#125; ... remoteEmitUse(fn, runtime) &#123; this.remoteEmitMiddleware.push(fn); if (runtime) &#123; this.remoteEmitFn = compose(this.remoteEmitMiddleware); &#125; return this; &#125; listen(config) &#123; this.socket = new WebSocket.Server(config); ... this.remoteEmitFn = compose(this.remoteEmitMiddleware); ... &#125; emit(event, args, isLocal = false) &#123; let arr = [event, args]; if (isLocal) &#123; super.emit.apply(this, arr); return this; &#125; let evt = &#123; event: event, args: args &#125; let remoteEmitContext = &#123; server: this, event: evt &#125;; this.remoteEmitFn(remoteEmitContext).catch(error =&gt; &#123; console.log(error) &#125;) return this; &#125;&#125;最后源码地址：easy-socket-node基于easy-socket-node与easy-socket-browser一个完整例子：index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script src=\"https://unpkg.com/easy-socket-browser@1.1.1/lib/easy-socket.min.js\"&gt;&lt;/script&gt;&lt;script&gt; &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script src=\"https://unpkg.com/easy-socket-browser@1.1.1/lib/easy-socket.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var client = new EasySocket(&#123; name: 'demo', autoReconnect: true, pingMsg: '&#123;\"type\":\"event\",\"event\":\"ping\",\"args\":\"ping\"&#125;'//模拟emit 消息体 &#125;); client.openUse((context, next) =&gt; &#123; console.log(\"open\"); next(); &#125;) .closeUse((context, next) =&gt; &#123; console.log(\"close\"); next(); &#125;).errorUse((context, next) =&gt; &#123; console.log(\"error\", context.event); next(); &#125;).messageUse((context, next) =&gt; &#123; if (context.res.type === 'event') &#123; context.client.emit(context.res.event, context.res.args, true); &#125; next(); &#125;) .reconnectUse((context, next) =&gt; &#123; console.log('正在进行重连') next(); &#125;) .remoteEmitUse((context, next) =&gt; &#123; let client = context.client; let event = context.event; if (client.socket.readyState !== 1) &#123; console.log(\"连接已断开\"); &#125; else &#123; client.socket.send(JSON.stringify(&#123; type: 'event', event: event.event, args: event.args &#125;)); next(); &#125; &#125;); client.connect('ws://localhost:3001'); var msg = 1; setInterval(() =&gt; &#123; client.emit('chatMessage', msg++) &#125;, 3000); client.on(\"serverMessage\", (data) =&gt; &#123; console.log(\"serverMessage:\" + data) &#125;);&lt;/script&gt;&lt;/html&gt;&lt;/script&gt;&lt;/html&gt;server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var EasySocket = require('easy-socket-node').default;var config = &#123; port: 3001, perMessageDeflate: &#123; zlibDeflateOptions: &#123; // See zlib defaults. chunkSize: 1024, memLevel: 7, level: 3, &#125;, zlibInflateOptions: &#123; chunkSize: 10 * 1024 &#125;, // Other options settable: clientNoContextTakeover: true, // Defaults to negotiated value. serverNoContextTakeover: true, // Defaults to negotiated value. //clientMaxWindowBits: 10, // Defaults to negotiated value. serverMaxWindowBits: 10, // Defaults to negotiated value. // Below options specified as default values. concurrencyLimit: 10, // Limits zlib concurrency for perf. threshold: 1024, // Size (in bytes) below which messages // should not be compressed. &#125;&#125;var remoteEmitMiddleware = (context, next) =&gt; &#123; var server = context.server; var event = context.event; for (let client of server.clients.values()) &#123; client.readyState == 1 &amp;&amp; client.send(makeEventMessage(event)); &#125;&#125;function makeEventMessage(event) &#123; return JSON.stringify(&#123; type: 'event', event: event.event, args: event.args &#125;)&#125;var messageRouteMiddleware = (routes) =&gt; &#123; return (context, next) =&gt; &#123; if (context.req.type === 'event') &#123; if (routes[context.req.event]) &#123; routes[context.req.event](context, next); &#125; else &#123; context.server.emit(context.req.event, context.req.args);//将会直接触发remoteEmitMiddleware 中间件的调用 next(); &#125; &#125; else &#123; next(); &#125; &#125;&#125;var router = &#123; chatMessage: (context, next) =&gt; &#123; var req = context.req; context.server.emit('serverMessage', req.args); &#125;&#125;var server = new EasySocket();server .connectionUse((context, next) =&gt; &#123; context.server.clients.set(1, context.client) console.log('new connection') &#125;) .closeUse((context, next) =&gt; &#123; console.log('close') &#125;) .messageUse(messageRouteMiddleware(router)) .remoteEmitUse(remoteEmitMiddleware) .listen(config)console.log('Now start WebSocket server on port ' + config.port + '...')运行过程，可以停止后端服务，然后再启动，测下心跳重连实现的聊天室例子：online chat demo聊天室前端源码：lazy-mock-im聊天室服务端源码：lazy-mock","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://jaycewu.site/tags/WebSocket/"}]},{"title":"以中间件，路由，跨进程事件的姿势使用WebSocket","slug":"以中间件，路由，跨进程事件的姿势使用WebSocket","date":"2018-11-05T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2018/11/05/以中间件，路由，跨进程事件的姿势使用WebSocket/","link":"","permalink":"https://jaycewu.site/2018/11/05/以中间件，路由，跨进程事件的姿势使用WebSocket/","excerpt":"","text":"通过参考koa中间件，socket.io远程事件调用，以一种新的姿势来使用WebSocket。浏览器端浏览器端使用WebSocket很简单123456789101112// Create WebSocket connection.const socket = new WebSocket('ws://localhost:8080');// Connection openedsocket.addEventListener('open', function (event) &#123; socket.send('Hello Server!');&#125;);// Listen for messagessocket.addEventListener('message', function (event) &#123; console.log('Message from server ', event.data);&#125;);MDN关于WebSocket的介绍能注册的事件有onclose，onerror，onmessage，onopen。用的比较多的是onmessage，从服务器接受到数据后，会触发message事件。通过注册相应的事件处理函数，可以根据后端推送的数据做相应的操作。如果只是写个demo,单单输出后端推送的信息,如下使用即可：123socket.addEventListener('message', function (event) &#123; console.log('Message from server ', event.data);&#125;);实际使用过程中，我们需要判断后端推送的数据然后执行相应的操作。比如聊天室应用中，需要判断消息是广播的还是私聊的或者群聊的，以及是纯文字信息还是图片等多媒体信息。这时message处理函数里可能就是一堆的if else。那么有没有什么别的优雅的姿势呢？答案就是中间件与事件，跨进程的事件的发布与订阅。在说远程事件发布订阅之前，需要先从中间件开始，因为后面实现的远程事件发布订阅是基于中间件的。中间件前面说了，在WebSocket实例上可以注册事件有onclose，onerror，onmessage，onopen。每一个事件的处理函数里可能需要做各种判断，特别是message事件。参考koa，可以将事件处理函数以中间件方式来进行使用，将不同的操作逻辑分发到不同的中间件中，比如聊天室应用中，聊天信息与系统信息(比如用户登录属于系统信息)是可以放到不同的中间件中处理的。koa提供use接口来注册中间件。我们针对不同的事件提供相应的中间件注册接口，并且对原生的WebSocket做封装。123456789101112131415161718192021222324252627282930export default class EasySocket&#123; constructor(config) &#123; this.url = config.url; this.openMiddleware = []; this.closeMiddleware = []; this.messageMiddleware = []; this.errorMiddleware = []; this.openFn = Promise.resolve(); this.closeFn = Promise.resolve(); this.messageFn = Promise.resolve(); this.errorFn = Promise.resolve(); &#125; openUse(fn) &#123; this.openMiddleware.push(fn); return this; &#125; closeUse(fn) &#123; this.closeMiddleware.push(fn); return this; &#125; messageUse(fn) &#123; this.messageMiddleware.push(fn); return this; &#125; errorUse(fn) &#123; this.errorMiddleware.push(fn); return this; &#125;&#125;通过xxxUse注册相应的中间件。 xxxMiddleware中就是相应的中间件。xxxFn 中间件通过compose处理后的结构再添加一个connect方法，处理相应的中间件并且实例化原生WebSocket1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253connect(url) &#123; this.url = url || this.url; if (!this.url) &#123; throw new Error('url is required!'); &#125; try &#123; this.socket = new WebSocket(this.url, 'echo-protocol'); &#125; catch (e) &#123; throw e; &#125; this.openFn = compose(this.openMiddleware); this.socket.addEventListener('open', (event) =&gt; &#123; let context = &#123; client: this, event &#125;; this.openFn(context).catch(error =&gt; &#123; console.log(error) &#125;); &#125;); this.closeFn = compose(this.closeMiddleware); this.socket.addEventListener('close', (event) =&gt; &#123; let context = &#123; client: this, event &#125;; this.closeFn(context).then(() =&gt; &#123; &#125;).catch(error =&gt; &#123; console.log(error) &#125;); &#125;); this.messageFn = compose(this.messageMiddleware); this.socket.addEventListener('message', (event) =&gt; &#123; let res; try &#123; res = JSON.parse(event.data); &#125; catch (error) &#123; res = event.data; &#125; let context = &#123; client: this, event, res &#125;; this.messageFn(context).then(() =&gt; &#123; &#125;).catch(error =&gt; &#123; console.log(error) &#125;); &#125;); this.errorFn = compose(this.errorMiddleware); this.socket.addEventListener('error', (event) =&gt; &#123; let context = &#123; client: this, event &#125;; this.errorFn(context).then(() =&gt; &#123; &#125;).catch(error =&gt; &#123; console.log(error) &#125;); &#125;); return this; &#125;使用koa-compose模块处理中间件。注意context传入了哪些东西，后续定义中间件的时候都可以使用。compose的作用可看这篇文章 傻瓜式解读koa中间件处理模块koa-compose然后就可以使用了：12345678910111213141516171819202122232425262728new EasySocket() .openUse((context, next) =&gt; &#123; console.log(\"open\"); next(); &#125;) .closeUse((context, next) =&gt; &#123; console.log(\"close\"); next(); &#125;) .errorUse((context, next) =&gt; &#123; console.log(\"error\", context.event); next(); &#125;) .messageUse((context, next) =&gt; &#123; //用户登录处理中间件 if (context.res.action === 'userEnter') &#123; console.log(context.res.user.name+' 进入聊天室'); &#125; next(); &#125;) .messageUse((context, next) =&gt; &#123; //创建房间处理中间件 if (context.res.action === 'createRoom') &#123; console.log('创建房间 '+context.res.room.anme); &#125; next(); &#125;) .connect('ws://localhost:8080')可以看到，用户登录与创建房间的逻辑放到两个中间件中分开处理。不足之处就是每个中间件都要判断context.res.action，而这个context.res就是后端返回的数据。怎么消除这个频繁的if判断呢? 我们实现一个简单的消息处理路由。路由定义消息路由中间件messageRouteMiddleware.js12345678910export default (routes) =&gt; &#123; return async (context, next) =&gt; &#123; if (routes[context.res.action]) &#123; await routes[context.res.action](context,next); &#125; else &#123; console.log(context.res) next(); &#125; &#125;&#125;定义路由router.js12345678910export default &#123; userEnter:function(context,next)&#123; console.log(context.res.user.name+' 进入聊天室'); next(); &#125;, createRoom:function(context,next)&#123; console.log('创建房间 '+context.res.room.anme); next(); &#125;&#125;使用：123456789101112131415new EasySocket() .openUse((context, next) =&gt; &#123; console.log(\"open\"); next(); &#125;) .closeUse((context, next) =&gt; &#123; console.log(\"close\"); next(); &#125;) .errorUse((context, next) =&gt; &#123; console.log(\"error\", context.event); next(); &#125;) .messageUse(messageRouteMiddleware(router))//使用消息路由中间件，并传入定义好的路由 .connect('ws://localhost:8080')一切都变得美好了，感觉就像在使用koa。想一个问题，当接收到后端推送的消息时，我们需要做相应的DOM操作。比如路由里面定义的userEnter，我们可能需要在对应的函数里操作用户列表的DOM，追加新用户。这使用原生JS或JQ都是没有问题的，但是如果使用vue,react这些，因为是组件化的，用户列表可能就是一个组件，怎么访问到这个组件实例呢？(当然也可以访问vuex,redux的store,但是并不是所有组件的数据都是用store管理的)。我们需要一个运行时注册中间件的功能，然后在组件的相应的生命周期钩子里注册中间件并且传入组件实例运行时注册中间件，修改如下代码：1234567messageUse(fn, runtime) &#123; this.messageMiddleware.push(fn); if (runtime) &#123; this.messageFn = compose(this.messageMiddleware); &#125; return this; &#125;修改 messageRouteMiddleware.js1234567891011export default (routes,component) =&gt; &#123; return async (context, next) =&gt; &#123; if (routes[context.req.action]) &#123; context.component=component;//将组件实例挂到context下 await routes[context.req.action](context,next); &#125; else &#123; console.log(context.req) next(); &#125; &#125;&#125;类似vue mounted中使用1234mounted()&#123; let client = this.$wsClients.get(\"im\");//获取指定EasySocket实例 client.messageUse(messageRouteMiddleware(router,this),true)//运行时注册中间件，并传入定义好的路由以及当前组件中的this&#125;路由中通过 context.component 即可访问到当前组件。完美了吗？每次组件mounted 都注册一次中间件，问题很大。所以需要一个判断中间件是否已经注册的功能。也就是一个支持具名注册中间件的功能。这里就暂时不实现了，走另外一条路，也就是之前说到的远程事件的发布与订阅，我们也可以称之为跨进程事件。跨进程事件看一段socket.io的代码：Server (app.js)12345678910111213141516171819202122var app = require('http').createServer(handler)var io = require('socket.io')(app);var fs = require('fs');app.listen(80);function handler (req, res) &#123; fs.readFile(__dirname + '/index.html', function (err, data) &#123; if (err) &#123; res.writeHead(500); return res.end('Error loading index.html'); &#125; res.writeHead(200); res.end(data); &#125;);&#125;io.on('connection', function (socket) &#123; socket.emit('news', &#123; hello: 'world' &#125;); socket.on('my other event', function (data) &#123; console.log(data); &#125;);&#125;);Client (index.html)12345678&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost'); socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;); &#125;);&lt;/script&gt;注意力转到这两部分：服务端1234socket.emit('news', &#123; hello: 'world' &#125;);socket.on('my other event', function (data) &#123; console.log(data);&#125;);客户端12345var socket = io('http://localhost');socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;);&#125;);使用事件，客户端通过on订阅’news’事件，并且当触发‘new’事件的时候通过emit发布’my other event’事件。服务端在用户连接的时候发布’news’事件，并且订阅’my other event’事件。一般我们使用事件的时候，都是在同一个页面中on和emit。而socket.io的神奇之处就是同一事件的on和emit是分别在客户端和服务端，这就是跨进程的事件。那么，在某一端emit某个事件的时候，另一端如果on监听了此事件，是如何知道这个事件emit(发布)了呢？没有看socket.io源码之前，我设想应该是emit方法里做了某些事情。就像java或c#，实现rpc的时候，可以依据接口定义动态生成实现(也称为代理)，动态实现的(代理)方法中，就会将当前方法名称以及参数通过相应协议进行序列化，然后通过http或者tcp等网络协议传输到RPC服务端，服务端进行反序列化，通过反射等技术调用本地实现，并返回执行结果给客户端。客户端拿到结果后，整个调用完成，就像调用本地方法一样实现了远程方法的调用。看了socket.io emit的代码实现后，思路也是大同小异，通过将当前emit的事件名和参数按一定规则组合成数据，然后将数据通过WebSocket的send方法发送出去。接收端按规则取到事件名和参数，然后本地触发emit。(注意远程emit和本地emit，socket.io中直接调用的是远程emit)。下面是实现代码，事件直接用的emitter模块，并且为了能自定义emit事件名和参数组合规则，以中间件的方式提供处理方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class EasySocket extends Emitter&#123;//继承Emitter constructor(config) &#123; this.url = config.url; this.openMiddleware = []; this.closeMiddleware = []; this.messageMiddleware = []; this.errorMiddleware = []; this.remoteEmitMiddleware = [];//新增的部分 this.openFn = Promise.resolve(); this.closeFn = Promise.resolve(); this.messageFn = Promise.resolve(); this.errorFn = Promise.resolve(); this.remoteEmitFn = Promise.resolve();//新增的部分 &#125; openUse(fn) &#123; this.openMiddleware.push(fn); return this; &#125; closeUse(fn) &#123; this.closeMiddleware.push(fn); return this; &#125; messageUse(fn) &#123; this.messageMiddleware.push(fn); return this; &#125; errorUse(fn) &#123; this.errorMiddleware.push(fn); return this; &#125; //新增的部分 remoteEmitUse(fn, runtime) &#123; this.remoteEmitMiddleware.push(fn); if (runtime) &#123; this.remoteEmitFn = compose(this.remoteEmitMiddleware); &#125; return this; &#125; connect(url) &#123; ... //新增部分 this.remoteEmitFn = compose(this.remoteEmitMiddleware); &#125; //重写emit方法，支持本地调用以远程调用 emit(event, args, isLocal = false) &#123; let arr = [event, args]; if (isLocal) &#123; super.emit.apply(this, arr); return this; &#125; let evt = &#123; event: event, args: args &#125; let remoteEmitContext = &#123; client: this, event: evt &#125;; this.remoteEmitFn(remoteEmitContext).catch(error =&gt; &#123; console.log(error) &#125;) return this; &#125;&#125;下面是一个简单的处理中间件：1234567891011121314client.remoteEmitUse((context, next) =&gt; &#123; let client = context.client; let event = context.event; if (client.socket.readyState !== 1) &#123; alert(\"连接已断开!\"); &#125; else &#123; client.socket.send(JSON.stringify(&#123; type: 'event', event: event.event, args: event.args &#125;)); next(); &#125; &#125;)意味着调用1234client.emit('chatMessage',&#123; from:'admin', masg:\"Hello WebSocket\"&#125;);就会组合成数据12345678&#123; type: 'event', event: 'chatMessage', args: &#123; from:'admin', masg:\"Hello WebSocket\" &#125;&#125;发送出去。服务端接受到这样的数据，可以做相应的数据处理（后面会使用nodejs实现类似的编程模式），也可以直接发送给别的客户端。客户受到类似的数据，可以写专门的中间件进行处理，比如：123456client.messageUse((context, next) =&gt; &#123; if (context.res.type === 'event') &#123; context.client.emit(context.res.event, context.res.args, true);//注意这里的emit是本地emit。 &#125; next();&#125;)如果本地订阅的chatMessage事件，回到函数就会被触发。在vue或react中使用，也会比之前使用路由的方式简单12345678910111213mounted() &#123; let client = this.$wsClients.get(\"im\"); client.on(\"chatMessage\", data =&gt; &#123; let isSelf = data.from.id == this.user.id; let msg = &#123; name: data.from.name, msg: data.msg, createdDate: data.createdDate, isSelf &#125;; this.broadcastMessageList.push(msg); &#125;);&#125;组件销毁的时候移除相应的事件订阅即可，或者清空所有事件订阅1234destroyed() &#123; let client = this.$wsClients.get(\"im\"); client.removeAllListeners();&#125;心跳重连核心代码直接从websocket-heartbeat-js copy过来的(用npm包，还得在它的基础上再包一层)，相关文章 初探和实现websocket心跳重连。核心代码：12345678910111213141516171819heartCheck() &#123; this.heartReset(); this.heartStart();&#125;heartStart() &#123; this.pingTimeoutId = setTimeout(() =&gt; &#123; //这里发送一个心跳，后端收到后，返回一个心跳消息 this.socket.send(this.pingMsg); //接收到心跳信息说明连接正常,会执行heartCheck(),重置心跳(清除下面定时器) this.pongTimeoutId = setTimeout(() =&gt; &#123; //此定时器有运行的机会，说明发送ping后，设置的超时时间内未收到返回信息 this.socket.close();//不直接调用reconnect，避免旧WebSocket实例没有真正关闭，导致不可预料的问题 &#125;, this.pongTimeout); &#125;, this.pingTimeout);&#125;heartReset() &#123; clearTimeout(this.pingTimeoutId); clearTimeout(this.pongTimeoutId);&#125;最后源码地址：easy-socket-browsernodejs实现的类似的编程模式(有空再细说)：easy-socket-node实现的聊天室例子：online chat demo聊天室前端源码：lazy-mock-im聊天室服务端源码：lazy-mock","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://jaycewu.site/tags/WebSocket/"}]},{"title":"傻瓜式解读koa中间件处理模块koa-compose","slug":"傻瓜式解读koa中间件处理模块koa-compose","date":"2018-10-29T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2018/10/29/傻瓜式解读koa中间件处理模块koa-compose/","link":"","permalink":"https://jaycewu.site/2018/10/29/傻瓜式解读koa中间件处理模块koa-compose/","excerpt":"","text":"最近需要单独使用到koa-compose这个模块，虽然使用koa的时候大致知道中间件的执行流程，但是没仔细研究过源码用起来还是不放心(主要是这个模块代码少，多的话也没兴趣去研究了)。koa-compose看起来代码少，但是确实绕。闭包，递归，Promise。。。看了一遍脑子里绕不清楚。看了网上几篇解读文章，都是针对单行代码做解释，还是绕不清楚。最后只好采取一种傻瓜的方式：koa-compose去掉一些注释，类型校验后，源码如下：12345678910111213141516171819function compose (middleware) &#123; return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125;写出如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var index = -1;function compose() &#123; return dispatch(0)&#125;function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i var fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve('fn is undefined') try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; function f1(context,next)&#123; console.log('middleware 1'); next().then(data=&gt;console.log(data)); console.log('middleware 1'); return 'middleware 1 return'; &#125; function f2(context,next)&#123; console.log('middleware 2'); next().then(data=&gt;console.log(data)); console.log('middleware 2'); return 'middleware 2 return'; &#125; function f3(context,next)&#123; console.log('middleware 3'); next().then(data=&gt;console.log(data)); console.log('middleware 3'); return 'middleware 3 return'; &#125;var middleware=[ f1,f2,f3]var context=&#123;&#125;;var next=function(context,next)&#123; console.log('middleware 4'); next().then(data=&gt;console.log(data)); console.log('middleware 4'); return 'middleware 4 return';&#125;;compose().then(data=&gt;console.log(data));直接运行结果如下：“middleware 1”“middleware 2”“middleware 3”“middleware 4”“middleware 4”“middleware 3”“middleware 2”“middleware 1”“fn is undefined”“middleware 4 return”“middleware 3 return”“middleware 2 return”“middleware 1 return”按着代码运行流程一步步分析：dispatch(0)i==0,index==-1 i&gt;index 往下index=0fn=f1Promise.resolve(f1(context, dispatch.bind(null, 0 + 1)))这就会执行f1(context, dispatch.bind(null, 0 + 1))进入到f1执行上下文console.log(&#39;middleware 1&#39;);输出middleware 1next()其实就是调用dispatch(1) bind的功劳递归开始dispatch(1)i==1,index==0 i&gt;index 往下index=1fn=f2Promise.resolve(f2(context, dispatch.bind(null, 1 + 1)))这就会执行f2(context, dispatch.bind(null, 1 + 1))进入到f2执行上下文console.log(&#39;middleware 2&#39;);输出middleware 2next()其实就是调用dispatch(2)接着递归dispatch(2)i==2,index==1 i&gt;index 往下index=2fn=f3Promise.resolve(f3(context, dispatch.bind(null, 2 + 1)))这就会执行f3(context, dispatch.bind(null, 2 + 1))进入到f3执行上下文console.log(&#39;middleware 3&#39;);输出middleware 3next()其实就是调用dispatch(3)接着递归dispatch(3)i==3,index==2 i&gt;index 往下index=3i === middleware.lengthfn=nextPromise.resolve(next(context, dispatch.bind(null, 3 + 1)))这就会执行next(context, dispatch.bind(null, 3 + 1))进入到next执行上下文console.log(&#39;middleware 4&#39;);输出middleware 4next()其实就是调用dispatch(4)接着递归dispatch(4)i==4,index==3 i&gt;index 往下index=4fn=middleware[4]fn=undefinedreuturn Promise.resolve(&#39;fn is undefined&#39;)回到next执行上下文console.log(&#39;middleware 4&#39;);输出middleware 4return &#39;middleware 4 return&#39;Promise.resolve(&#39;middleware 4 return&#39;)回到f3执行上下文console.log(&#39;middleware 3&#39;);输出middleware 3return &#39;middleware 3 return&#39;Promise.resolve(&#39;middleware 3 return&#39;)回到f2执行上下文console.log(&#39;middleware 2&#39;);输出middleware 2return &#39;middleware 2 return&#39;Promise.resolve(&#39;middleware 2 return&#39;)回到f1执行上下文console.log(&#39;middleware 1&#39;);输出middleware 1return &#39;middleware 1 return&#39;Promise.resolve(&#39;middleware 1 return&#39;)回到全局上下文至此已经输出“middleware 1”“middleware 2”“middleware 3”“middleware 4”“middleware 4”“middleware 3”“middleware 2”“middleware 1”那么“fn is undefined”“middleware 4 return”“middleware 3 return”“middleware 2 return”“middleware 1 return”怎么来的呢回头看一下，每个中间件里都有next().then(data=&gt;console.log(data));按照之前的分析，then里最先拿到结果的应该是next中间件的，而且结果就是Promise.resolve(&#39;fn is undefined&#39;)的结果，然后分别是f4,f3,f2,f1。那么为什么都是最后才输出呢？12Promise.resolve('fn is undefined').then(data=&gt;console.log(data));console.log('middleware 4');运行一下就清楚了或者12setTimeout(()=&gt;console.log('fn is undefined'),0);console.log('middleware 4');整个调用过程还可以看成是这样的：1234567891011121314151617181920function composeDetail()&#123; return Promise.resolve( f1(context,function()&#123; return Promise.resolve( f2(context,function()&#123; return Promise.resolve( f3(context,function()&#123; return Promise.resolve( next(context,function()&#123; return Promise.resolve('fn is undefined') &#125;) ) &#125;) ) &#125;) ) &#125;) )&#125;composeDetail().then(data=&gt;console.log(data));方法虽蠢，但是compose的作用不言而喻了最后，if (i &lt;= index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))这句代码何时回其作用呢？一个中间件里调用两次next()，按照上面的套路走，相信很快就明白了。","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://jaycewu.site/tags/koa/"},{"name":"compose","slug":"compose","permalink":"https://jaycewu.site/tags/compose/"},{"name":"中间件","slug":"中间件","permalink":"https://jaycewu.site/tags/中间件/"}]},{"title":"企业管理系统前后端分离架构设计  系列一  权限模型篇","slug":"企业管理系统前后端分离架构设计  系列一  权限模型篇","date":"2018-10-22T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2018/10/22/企业管理系统前后端分离架构设计  系列一  权限模型篇/","link":"","permalink":"https://jaycewu.site/2018/10/22/企业管理系统前后端分离架构设计  系列一  权限模型篇/","excerpt":"","text":"术语描述用户(Subject)：发起操作的主体对象(Object)：指操作所针对的客体对象，比如文章或评论权限(Permission)：用来指代对某种对象的某一种操作，例如“添加文章的操作”权限码：权限的代号，例如用“ARTICLE_ADD”来指代“添加文章的操作”权限权限有时候也可以称为动作或者功能。比如“添加文章”，既可以认为它是一个动作，也可以认为它是一个功能。对象也可以称为资源。常用的权限模型ACL(Access Control List)(访问控制列表)DAC(Discretionary Access Control)(自主访问控制)MAC(Mandatory Access Control)(强制访问控制)RBAC(Role-Based Access Control)(基于角色的访问控制)ABAC(Attribute-Based Access Control)(基于属性的访问控制)ACL(Access Control List)(访问控制列表)ACL是最早也是最基本的一种访问控制机制，它是用来描述用户和权限之间关系的数据列表。它的原理非常简单：每一项资源，都配有一个列表，这个列表记录的就是哪些用户可以对这项资源执行CRUD等操作。当试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确定当前用户可否执行相应的操作。例如一个文件对象的 ACL 为 Alice: read,write; Bob: read，这代表 Alice 对该文件既能读又能写，而 Bob 只能读取。由于ACL的简单性，使得它几乎不需要任何基础设施就可以完成访问控制。但同时它的缺点也是很明显的，由于需要维护大量的访问权限列表，ACL在性能上有明显的缺陷。另外，对于拥有大量用户与众多资源的应用，管理访问控制列表本身就变成非常繁重的工作。最开始的ACL定义中，用户直接和权限挂钩，数据存储的是用户与权限的关联关系。如果两个用户的权限是一样的，那么就需要分别存储这两个用户与权限的关联关系，也是上面所提到的ACL的缺陷。为了解决这些问题，便有了对ACL设计的改进，相同权限的用户放到同一个分组里，分组与权限挂钩，不再是用户直接与权限挂钩。以及后来出现的RBAC(基于角色的访问控制)，角色与分组也是差不多的概念，角色直接与权限挂钩，用户再与角色进行关联。所以，现在一般说ACL,不再是用户直接和权限挂钩的一种权限控制模型，把它看做一个单纯的访问控制列表即可。列表里维护的可能是用户与权限的关系，也可以是用户组与权限的关系，也可以是角色与权限的关系，甚至是部门，职位等等于权限的关系。ACL是权限体系中的业务规则。RBAC等权限模型要用到ACL才能工作，ACL服务于RBAC等权限模型，其它权限控制体系里的权限规则也叫ACL。DAC(Discretionary Access Control)(自主访问控制)系统会识别用户，然后根据被操作对象（Subject）的权限控制列表（ACL: Access Control List）或者权限控制矩阵（ACL: Access Control Matrix）的信息来决定用户的是否能对其进行哪些操作，例如读取或修改。而拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为“自主（Discretionary）”控制。因为用户能自主地将自己拥有的权限授予其他用户，所以DAC模型可以任意传递权限，用户能间接获得本不具有的访问权限，因此DAC模型的安全性较低，不能给系统充分的数据保护。DAC可以直接使用ACL的物理模型，区别在于，DAC模型中用户可以将自己具备的权限分配给其它用户(程序里的操作就是根据用户ID筛选出权限列表，根据列表为要分配权限的用户构造出新的权限列表并保存)DAC是传统的UNIX访问控制模型，也是Windows文件系统的访问控制模型。Windows的文件访问权限的设置中，除了用户，还有组。这个组与后面要说到的RABC模型的角色有什么区别呢？https://stackoverflow.com/questions/7770728/group-vs-role-any-real-difference我认为没必要去划分的太清楚，不管是组还是角色，都是为了更好的管理和分配权限在最原始的ACL模型上做的改进。如果有需要，甚至可以把权限分配到部门，职位上。MAC(Mandatory Access Control)(强制访问控制)MAC是为了弥补DAC权限控制过于分散的问题而诞生的。在MAC的设计中，每一个对象都有一些权限标识，每个用户同样也会有一些权限标识，而用户能否对该对象进行操作取决于双方的权限标识的关系，这个限制判断通常是由系统硬性限制的。访问时，系统先对用户的访问许可级别和资源对象的密级进行比较，再决定用户是否可以访问资源对象。用户不能改变自身和资源对象的安全级别，只有系统管理员或管理程序才能 控制资源对象和用户的级别。比如在影视作品中我们经常能看到特工在查询机密文件时，屏幕提示需要“无法访问，需要一级安全许可”，这个例子中，文件上就有“一级安全许可”的权限标识，而用户并不具有。MAC非常适合机密机构或者其他等级观念强烈的行业，但对于类似商业服务系统，则因为不够灵活而不能适用。MAC可以继续使用DAC的模型，但是要对用户进行等级划分，比如一级，二级，三级。。。，对对象资源也要做划分，比如机密，秘密和最高机密。用户访问的资源的时候，根据用户等级与资源访问级别来做判断，比如一级用户只能访问机密文件，如果访问的是最高机密文件，系统就会拒绝。这一系列规则是优先于DAC的，如果MAC与DAC混用，要先校验MAC再校验DAC。RBAC(Role-Based Access Control)(基于角色的访问控制)ACL的访问控制机制中，直接维护的是用户与功能的关系，这一系列的关系就是一个权限列表。当很多的用户具有相同功能权限的时候，就要进行繁琐的关联操作。RBAC就是在用户与权限之间引入了角色的概念。用户与角色之间做关联，权限列表维护的是角色与功能的关系。RBAC是目前使用最普遍的权限控制模型。当某些用户具备相同的权限的时候，只需要为这些用户建一个角色，把相应的功能关联到这个角色上，生成角色的权限列表。当有新的用户需要相同权限的时候，把用户关联到这个角色上即可。而当用检查或校验用户的操作权限的时候，查询用户所属角色的权限列表即可。当然，RBAC也不是完美的，比如想要为某个用户单独设置某个功能权限，可能需要为这个功能权限单独创建一个角色，然后把特定的用户关联到这个角色上。当想要移除某个用户的特定功能权限的时候，可能需要重新设置角色的功能权限，把特定功能权限从当前角色中移除，建立新的角色并关联特定的功能权限，然后再把新角色与相关的用户做关联(也可以直接在特定功能的程序里校验操作用户)这里说一个比较常见的RBAC的错误的用法：那就是直接使用角色做权限判断。比如只有角色A才能做文章的删除操作。12345function delPost(postId)&#123; if(!isRole('A'))&#123; return false; &#125;&#125;如果需求该为角色B也可以删除文章。那就必须修改代码12345function delPost(postId)&#123; if(!isRole('A')&amp;&amp;!isRole('B'))&#123; return false; &#125;&#125;正确的做法应该是添加”删除文章”这个功能，把这个功能关联到相应的角色上。判断的时候是根据功能去判断而不是角色。12345function delPost(postId)&#123; if(!hasPermission('POST_DEL'))&#123; return false; &#125;&#125;针对“只有角色A才能做文章的删除操作”这一需求，把这个删除功能关联到角色A上，然后把需要这个操作权限的用户加入到角色A中即可。当别的角色也需要这个操作权限，把功能关联到对应角色上即可，不需要再修改代码。在RBAC的核心基础上，还可以做相应的扩展，比如角色继承，角色分组之类的，这些扩展都是为了在一定程度简化权限管理工作。ABAC(Attribute-Based Access Control)(基于属性的权限控制)RBAC虽然是目前最普遍的权限控制模型。但是某些情况下，RBAC是无法满足并且也实现不了的。比如业务员1和业务员2都属于业务员角色，都有查看客户订单的权限。当有一个需求，要求业务员1只能查看北京地区的客户的订单，业务员2只能查看上海的客户的订单。这单单使用RBAC是无法实现。借助RBAC，可行的做法是，分地区创建角色，然后程序中根据角色做数据的过滤，这种做法缺点之前也提到过，需求变更的时候可能需要每次都修改代码。上面业务员查看订单的例子，地区是订单的一个属性，需求就是针对这个地区属性来做订单的查询范围的权限控制。这种权限控制方式就是ABAC(Attribute-Based Access Control)(基于属性的权限控制)，也被一些人称为是权限系统设计的未来。不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性是否满足某种条件来进行授权判断的（可以编写简单的逻辑）。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。ABAC非常的灵活，但是实现也是非常的难。这其中涉及到逻辑的动态执行，数据动态过滤等，更加具体就是动态拼接SQL语句(使用ORM的话就是动态组装对应ORM的查询语句)。感兴趣的可以在Github上搜索ABAC，看看不同语言是否已经有现成的解决方案。下面说说我学习到的一种实现方式：还是业务员查看订单的例子，在RBAC的基础上，扩展一个实体规则，订单就是实体，也就是针对订单设置一系列的规则。规则存储格式可以是json也可以是xml,甚至是Sql语句，能解析即可。比如北京地区这个规则：123&#123; \"regionId\":1&#125;上海地区：123&#123; \"regionId\":3&#125;regionId 就是系统里对应区域的Id,也是订单或订单相关表的某个字段。保存这个规则的时候，规则内容(就是上面的json),规则实体(也就是订单，表明这个规则是针对订单的)是必须的。也可以加上这个规则是适用增删改查中的一种或多种。创建好实体的规则，将规则与角色做关联，也就是将北京地区的规则关联到北京地区角色上，上海地区的规则关联到上海地区角色上。后端做权限校验的时候，还是先按RBAC模型的控制方式进行校验(是否具备订单查看权限)，然后根据当前操作对象(也就是实体)，取出用户所属角色关联的对应实体的规则。然后解析规则，动态拼接Sql或者ORM语句。没做地区限制(或没配置规则)的时候，Sql可能是1select userId,orderNo,createdDate from T_Order配置了规则，解析拼接后可能就是1select userId,orderNo,createdDate from T_Order where regionId=1这里是针对地区这个属性实现了动态的权限控制。实际开发过程中，要控制的东西是非常多了，查看字段的控制，数据范围的控制。要满足这些复杂的控制，需要制定一套完整的规则，以及针对规则编写相应的解析程序。比如根据配置的规则，最后解析出来可能是各种Sql语句:&lt;,&gt;,=,like,in,not in等等。可以看出，要真正的落地实现ABAC是多么的复杂。每次都要解析规则，对程序的性能也造成的影响，就算使用缓存，命中的概率也是非常的小，因为很多因素都是动态的。所以，如果需要根据属性做权限判断的场景不是很多的话，还是建议使用RBAC，然后程序中做判断比较省事省力。总结ACL早期定义中是一种权限控制机制，这种机制直接维护的是用户与功能的关系，功能就是针对对象定义的一些操作，比如增删改查的等。用户与功能的关系列表也称为权限列表或访问控制列表，现在说ACL，一般就是指这个权限列表或访问控制列表，但是里面维护的关系不一定是用户与功能的关系，在RBAC中维护的就是角色与功能的关系。RBAC在ACL的基础上加入了角色的概念，权限列表或访问控制列表里维护的不再是用户与功能的关系，而是角色与功能的关系。ACL可以和RBAC混着用，既可以在角色上设置权限，也可以直接给用户设置权限，更加灵活。借助角色的思想，可以在用户组，组织，职位等等上设置权限，以便更好的做好权限管理，也就是将权限设置从单一个体转移到某一类组合上。ABAC非常的灵活，也非常的难实现。参考文章权限系统设计模型分析Authorization Models: ACL, DAC, MAC, RBAC, ABAC","categories":[{"name":"架构","slug":"架构","permalink":"https://jaycewu.site/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://jaycewu.site/tags/架构/"},{"name":"前后端分离","slug":"前后端分离","permalink":"https://jaycewu.site/tags/前后端分离/"},{"name":"权限管理","slug":"权限管理","permalink":"https://jaycewu.site/tags/权限管理/"}]},{"title":"vue权限路由实现方式总结","slug":"vue权限路由实现方式总结","date":"2018-07-28T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2018/07/28/vue权限路由实现方式总结/","link":"","permalink":"https://jaycewu.site/2018/07/28/vue权限路由实现方式总结/","excerpt":"","text":"使用全局路由守卫实现前端定义好路由，并且在路由上标记相应的权限信息1234567891011121314151617181920212223242526272829const routerMap = [ &#123; path: '/permission', component: Layout, redirect: '/permission/index', alwaysShow: true, // will always show the root menu meta: &#123; title: 'permission', icon: 'lock', roles: ['admin', 'editor'] // you can set roles in root nav &#125;, children: [&#123; path: 'page', component: () =&gt; import('@/views/permission/page'), name: 'pagePermission', meta: &#123; title: 'pagePermission', roles: ['admin'] // or you can only set roles in sub nav &#125; &#125;, &#123; path: 'directive', component: () =&gt; import('@/views/permission/directive'), name: 'directivePermission', meta: &#123; title: 'directivePermission' // if do not set roles, means: this page does not require permission &#125; &#125;] &#125;]全局路由守卫每次都判断用户是否已经登录，没有登录则跳到登录页。已经登录(已经取得后台返回的用户的权限信息(角色之类的))，则判断当前要跳转的路由，用户是否有权限访问(根据路由名称到全部路由里找到对应的路由，判断用户是否具备路由上标注的权限信息(比如上面的roles: [&#39;admin&#39;, &#39;editor&#39;]))。没有权限则跳到事先定义好的界面(403,404之类的)。这种方式，菜单可以直接用路由生成(用户没有权限的菜单也会显示，点击跳转的时候才做权限判断)，也可以在用户登录后根据用户权限把路由过滤一遍生成菜单(菜单需要保存在vuex里)。目前iview-admin还是用的这种方式缺点加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。全局路由守卫里，每次路由跳转都要做权限判断。菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识登录页与主应用分离针对前一种实现方式的缺点，可以将登录页与主应用放到不同的页面(不在同一个vue应用实例里)。实现登录成功后，进行页面跳转(真正的页面跳转，不是路由跳转)，并将用户权限传递到主应用所在页面，主应用初始化之前，根据用户权限筛选路由，筛选后的路由作为vue的实例化参数，而不是像前一种方式所有的路由都传递进去，也不需要在全局路由守卫里做权限判断了。缺点需要做页面跳转，不是纯粹的单页应用菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识使用addRoutes动态挂载路由addRoutes允许在应用初始化之后，动态的挂载路由。有了这个新姿势，就不用像前一种方式那样要在应用初始化之要对路由进行筛选。实现应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。有个问题，addRoutes应该何时调用，在哪里调用登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。所以addRoutes还是要在全局路由守卫里进行调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import router from './router'import store from './store'import &#123; Message &#125; from 'element-ui'import NProgress from 'nprogress' // progress barimport 'nprogress/nprogress.css'// progress bar styleimport &#123; getToken &#125; from '@/utils/auth' // getToken from cookieNProgress.configure(&#123; showSpinner: false &#125;)// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) &#123; if (roles.indexOf('admin') &gt;= 0) return true // admin permission passed directly if (!permissionRoles) return true return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)&#125;const whiteList = ['/login', '/authredirect']// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; &#123; NProgress.start() // start progress bar if (getToken()) &#123; // determine if there has token /* has token*/ if (to.path === '/login') &#123; next(&#123; path: '/' &#125;) NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it &#125; else &#123; if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetUserInfo').then(res =&gt; &#123; // 拉取user_info const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop'] store.dispatch('GenerateRoutes', &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;) &#125;).catch((err) =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; Message.error(err || 'Verification failed, please login again') next(&#123; path: '/' &#125;) &#125;) &#125;) &#125; else &#123; // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓ if (hasPermission(store.getters.roles, to.meta.roles)) &#123; next()// &#125; else &#123; next(&#123; path: '/401', replace: true, query: &#123; noGoBack: true &#125;&#125;) &#125; // 可删 ↑ &#125; &#125; &#125; else &#123; /* has no token*/ if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next('/login') // 否则全部重定向到登录页 NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it &#125; &#125;&#125;)router.afterEach(() =&gt; &#123; NProgress.done() // finish progress bar&#125;)关键的代码如下12345678910111213if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetUserInfo').then(res =&gt; &#123; // 拉取user_info const roles = res.data.roles // note: roles must be a array! such as: ['editor','develop'] store.dispatch('GenerateRoutes', &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;) &#125;).catch((err) =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; Message.error(err || 'Verification failed, please login again') next(&#123; path: '/' &#125;) &#125;) &#125;)上面的代码就是vue-element-admin的实现缺点全局路由守卫里，每次路由跳转都要做判断菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识菜单与路由分离，菜单由后端返回菜单的显示标题，图片等需要随时更改，要对菜单做管理功能。后端直接根据用户权限返回可访问的菜单。实现前端定义路由信息(标准的路由定义，不需要加其他标记字段)。12345&#123; name: \"login\", path: \"/login\", component: () =&gt; import(\"@/pages/Login.vue\")&#125;name字段都不为空，需要根据此字段与后端返回菜单做关联。做菜单管理功能的时候，一定要有个字段与前端的路由的name字段对应上(也可以是其他字段，只要菜单能找到对应的路由或者路由能找到对应的菜单就行)，并且做唯一性校验。菜单上还需要定义权限字段，可以是一个或多个。其他信息，比如显示标题，图标，排序，锁定之类的，可以根据实际需求进行设计。还是在全局路由守卫里做判断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function hasPermission(router, accessMenu) &#123; if (whiteList.indexOf(router.path) !== -1) &#123; return true; &#125; let menu = Util.getMenuByName(router.name, accessMenu); if (menu.name) &#123; return true; &#125; return false;&#125;Router.beforeEach(async (to, from, next) =&gt; &#123; if (getToken()) &#123; let userInfo = store.state.user.userInfo; if (!userInfo.name) &#123; try &#123; await store.dispatch(\"GetUserInfo\") await store.dispatch('updateAccessMenu') if (to.path === '/login') &#123; next(&#123; name: 'home_index' &#125;) &#125; else &#123; //Util.toDefaultPage([...routers], to.name, router, next); next(&#123; ...to, replace: true &#125;)//菜单权限更新完成,重新进一次当前路由 &#125; &#125; catch (e) &#123; if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next('/login') &#125; &#125; &#125; else &#123; if (to.path === '/login') &#123; next(&#123; name: 'home_index' &#125;) &#125; else &#123; if (hasPermission(to, store.getters.accessMenu)) &#123; Util.toDefaultPage(store.getters.accessMenu,to, routes, next); &#125; else &#123; next(&#123; path: '/403',replace:true &#125;) &#125; &#125; &#125; &#125; else &#123; if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next() &#125; else &#123; next('/login') &#125; &#125; let menu = Util.getMenuByName(to.name, store.getters.accessMenu); Util.title(menu.title);&#125;);Router.afterEach((to) =&gt; &#123; window.scrollTo(0, 0);&#125;);上面代码是vue-quasar-admin的实现。因为没有使用addRoutes,每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的,而后端返回的菜单就已经是经过权限过滤的，所以如果根据路由name找不到对应的菜单，就表示用户有没权限访问。如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载。缺点菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用全局路由守卫里，每次路由跳转都要做判断菜单与路由完全由后端返回菜单由后端返回是可行的，但是路由由后端返回呢？看一下路由的定义12345&#123; name: \"login\", path: \"/login\", component: () =&gt; import(\"@/pages/Login.vue\")&#125;后端如果直接返回12345&#123; \"name\": \"login\", \"path\": \"/login\", \"component\": \"() =&gt; import('@/pages/Login.vue')\"&#125;这是什么鬼，明显不行。() =&gt; import(&#39;@/pages/Login.vue&#39;)这代码如果没出现在前端，webpack不会对Login.vue进行编译打包实现前端统一定义路由组件，比如123456const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);export default &#123; home: Home, userInfo: UserInfo&#125;;将路由组件定义为这种key-value的结构。后端返回格式123456789101112[ &#123; name: \"home\", path: \"/\", component: \"home\" &#125;, &#123; name: \"home\", path: \"/userinfo\", component: \"userInfo\" &#125;]在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件。至于菜单与路由是否还要分离，怎么对应，可以根据实际需求进行处理。如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段。前端拿到数据也要做相应的处理。缺点全局路由守卫里，每次路由跳转都要做判断前后端的配合要求更高不使用全局路由守卫前面几种方式，除了登录页与主应用分离,每次路由跳转，都在全局路由守卫里做了判断。实现应用初始化的时候只挂载不需要权限控制的路由1234567891011121314151617181920const constRouterMap = [ &#123; name: \"login\", path: \"/login\", component: () =&gt; import(\"@/pages/Login.vue\") &#125;, &#123; path: \"/404\", component: () =&gt; import(\"@/pages/Page404.vue\") &#125;, &#123; path: \"/init\", component: () =&gt; import(\"@/pages/Init.vue\") &#125;, &#123; path: \"*\", redirect: \"/404\" &#125;];export default constRouterMap;1234567891011import Vue from \"vue\";import Router from \"vue-router\";import ConstantRouterMap from \"./routers\";Vue.use(Router);export default new Router(&#123; // mode: 'history', // require service support scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: ConstantRouterMap&#125;);登录成功后跳到/路由123456789101112131415161718submitForm(formName) &#123; let _this=this; this.$refs[formName].validate(valid =&gt; &#123; if (valid) &#123; _this.$store.dispatch(\"loginByUserName\",&#123; name:_this.ruleForm2.name, pass:_this.ruleForm2.pass &#125;).then(()=&gt;&#123; _this.$router.push(&#123; path:'/' &#125;) &#125;) &#125; else &#123; return false; &#125; &#125;); &#125;因为当前没有/路由，会跳到/404123456789101112131415161718&lt;template&gt; &lt;h1&gt;404&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'page404', mounted()&#123; if(!this.$store.state.isLogin)&#123; this.$router.replace(&#123; path: '/login' &#125;); return; &#125; if(!this.$store.state.initedApp)&#123; this.$router.replace(&#123; path: '/init' &#125;); return &#125; &#125;&#125;&lt;/script&gt;404组件里判断已经登录，接着判断应用是否已经初始化(用户权限信息，可访问菜单，路由等是否已经从后端取得)。没有初始化则跳转到/init路由1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; getAccessMenuList &#125; from \"../mock/menus\";import components from \"../router/routerComponents.js\";export default &#123; async mounted() &#123; if (!this.$store.state.isLogin) &#123; this.$router.push(&#123; path: \"/login\" &#125;); return; &#125; if (!this.$store.state.initedApp) &#123; const loading = this.$loading(&#123; lock: true, text: \"初始化中\", spinner: \"el-icon-loading\", background: \"rgba(0, 0, 0, 0.7)\" &#125;); let menus = await getAccessMenuList(); //模拟从后端获取 var routers = [...menus]; for (let router of routers) &#123; let component = components[router.component]; router.component = component; &#125; this.$router.addRoutes(routers); this.$store.dispatch(\"setAccessMenuList\", menus).then(() =&gt; &#123; loading.close(); this.$router.replace(&#123; path: \"/\" &#125;); &#125;); return; &#125; else &#123; this.$router.replace(&#123; path: \"/\" &#125;); &#125; &#125;&#125;;&lt;/script&gt;init组件里判断应用是否已经初始化(避免初始化后，直接从地址栏输入地址再次进入当前组件)。如果已经初始化，跳转/路由(如果后端返回的路由里没有定义次路由，则会跳转404)。没有初始化，则调用远程接口获取菜单和路由等，然后处理后端返回的路由，将component赋值为真正的组件，接着调用addRoutes挂载新路由，最后跳转/路由即可。菜单的处理也是在此处，看实际需求。实现例子缺点在404页面做了判断，感觉比较怪异多引入了一个init页面组件总结比较推荐后面两种实现方式。","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://jaycewu.site/tags/vue/"}]},{"title":"IdentityServer4实现Token认证登录以及权限控制","slug":"IdentityServer4实现Token登录以及权限控制","date":"2017-11-05T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/11/05/IdentityServer4实现Token登录以及权限控制/","link":"","permalink":"https://jaycewu.site/2017/11/05/IdentityServer4实现Token登录以及权限控制/","excerpt":"","text":"相关知识点不再对IdentityServer4做相关介绍，博客园上已经有人出了相关的系列文章，不了解的可以看一下：蟋蟀大神的：小菜学习编程-IdentityServer4晓晨Master：IdentityServer4以及Identity,Claim等相关知识：Savorboard： ASP.NET Core 之 Identity 入门（一），ASP.NET Core 之 Identity 入门（二）创建IndentityServer4 服务创建一个名为QuickstartIdentityServer的ASP.NET Core Web 空项目（asp.net core 2.0），端口5000NuGet包：修改Startup.cs 设置使用IdentityServer：123456789101112131415161718192021222324public class Startup &#123; public void ConfigureServices(IServiceCollection services) &#123; // configure identity server with in-memory stores, keys, clients and scopes services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryIdentityResources(Config.GetIdentityResourceResources()) .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients()) .AddResourceOwnerValidator&lt;ResourceOwnerPasswordValidator&gt;() .AddProfileService&lt;ProfileService&gt;(); &#125; public void Configure(IApplicationBuilder app, IHostingEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseIdentityServer(); &#125; &#125;添加Config.cs配置IdentityResource，ApiResource以及Client：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Config &#123; public static IEnumerable&lt;IdentityResource&gt; GetIdentityResourceResources() &#123; return new List&lt;IdentityResource&gt; &#123; new IdentityResources.OpenId(), //必须要添加，否则报无效的scope错误 new IdentityResources.Profile() &#125;; &#125; // scopes define the API resources in your system public static IEnumerable&lt;ApiResource&gt; GetApiResources() &#123; return new List&lt;ApiResource&gt; &#123; new ApiResource(\"api1\", \"My API\") &#125;; &#125; // clients want to access resources (aka scopes) public static IEnumerable&lt;Client&gt; GetClients() &#123; // client credentials client return new List&lt;Client&gt; &#123; new Client &#123; ClientId = \"client1\", AllowedGrantTypes = GrantTypes.ClientCredentials, ClientSecrets = &#123; new Secret(\"secret\".Sha256()) &#125;, AllowedScopes = &#123; \"api1\",IdentityServerConstants.StandardScopes.OpenId, //必须要添加，否则报forbidden错误 IdentityServerConstants.StandardScopes.Profile&#125;, &#125;, // resource owner password grant client new Client &#123; ClientId = \"client2\", AllowedGrantTypes = GrantTypes.ResourceOwnerPassword, ClientSecrets = &#123; new Secret(\"secret\".Sha256()) &#125;, AllowedScopes = &#123; \"api1\",IdentityServerConstants.StandardScopes.OpenId, //必须要添加，否则报forbidden错误 IdentityServerConstants.StandardScopes.Profile &#125; &#125; &#125;; &#125; &#125;因为要使用登录的时候要使用数据中保存的用户进行验证，要实IResourceOwnerPasswordValidator接口：1234567891011121314151617181920212223242526272829303132333435363738public class ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator &#123; public ResourceOwnerPasswordValidator() &#123; &#125; public async Task ValidateAsync(ResourceOwnerPasswordValidationContext context) &#123; //根据context.UserName和context.Password与数据库的数据做校验，判断是否合法 if (context.UserName==\"wjk\"&amp;&amp;context.Password==\"123\") &#123; context.Result = new GrantValidationResult( subject: context.UserName, authenticationMethod: \"custom\", claims: GetUserClaims()); &#125; else &#123; //验证失败 context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, \"invalid custom credential\"); &#125; &#125; //可以根据需要设置相应的Claim private Claim[] GetUserClaims() &#123; return new Claim[] &#123; new Claim(\"UserId\", 1.ToString()), new Claim(JwtClaimTypes.Name,\"wjk\"), new Claim(JwtClaimTypes.GivenName, \"jaycewu\"), new Claim(JwtClaimTypes.FamilyName, \"yyy\"), new Claim(JwtClaimTypes.Email, \"977865769@qq.com\"), new Claim(JwtClaimTypes.Role,\"admin\") &#125;; &#125; &#125;IdentityServer提供了接口访问用户信息，但是默认返回的数据只有sub，就是上面设置的subject: context.UserName，要返回更多的信息，需要实现IProfileService接口：12345678910111213141516171819202122public class ProfileService : IProfileService &#123; public async Task GetProfileDataAsync(ProfileDataRequestContext context) &#123; try &#123; //depending on the scope accessing the user data. var claims = context.Subject.Claims.ToList(); //set issued claims to return context.IssuedClaims = claims.ToList(); &#125; catch (Exception ex) &#123; //log your error &#125; &#125; public async Task IsActiveAsync(IsActiveContext context) &#123; context.IsActive = true; &#125;context.Subject.Claims就是之前实现IResourceOwnerPasswordValidator接口时claims: GetUserClaims()给到的数据。另外，经过调试发现，显示执行ResourceOwnerPasswordValidator 里的ValidateAsync，然后执行ProfileService 里的IsActiveAsync，GetProfileDataAsync。启动项目，使用postman进行请求就可以获取到token：再用token获取相应的用户信息：token认证服务一般是与web程序分开的，上面创建的QuickstartIdentityServer项目就相当于服务端，我们需要写业务逻辑的web程序就相当于客户端。当用户请求web程序的时候，web程序拿着用户已经登录取得的token去IdentityServer服务端校验。创建web应用创建一个名为API的ASP.NET Core Web 空项目（asp.net core 2.0），端口5001。NuGet包：修改Startup.cs 设置使用IdentityServer进行校验：123456789101112131415161718192021222324252627public class Startup &#123; public void ConfigureServices(IServiceCollection services) &#123; services.AddMvcCore(option=&gt; &#123; option.Filters.Add(new TestAuthorizationFilter()); &#125;).AddAuthorization() .AddJsonFormatters(); services.AddAuthentication(\"Bearer\") .AddIdentityServerAuthentication(options =&gt; &#123; options.Authority = \"http://localhost:5000\"; options.RequireHttpsMetadata = false; options.ApiName = \"api1\"; &#125;); &#125; public void Configure(IApplicationBuilder app) &#123; app.UseAuthentication(); app.UseMvc(); &#125; &#125;创建IdentityController：1234567891011[Route(\"[controller]\")] public class IdentityController : ControllerBase &#123; [HttpGet] [Authorize] public IActionResult Get() &#123; return new JsonResult(\"Hello Word\"); &#125; &#125;分别运行QuickstartIdentityServer，API项目。用生成的token访问API：通过上述程序，已经可以做一个前后端分离的登录功能。实际上，web应用程序中我们经常需要获取当前用户的相关信息进行操作，比如记录用户的一些操作日志等。之前说过IdentityServer提供了接口/connect/userinfo来获取用户的相关信息。之前我的想法也是web程序中拿着token去请求这个接口来获取用户信息，并且第一次获取后做相应的缓冲。但是感觉有点怪怪的，IdentityServer不可能没有想到这一点，正常的做法应该是校验通过会将用户的信息返回的web程序中。问题又来了，如果IdentityServer真的是这么做的，web程序该怎么获取到呢，查了官方文档也没有找到。然后就拿着”Claim”关键字查了一通（之前没了解过ASP.NET Identity），最后通过HttpContext.User.Claims取到了设置的用户信息：修改IdentityController ：1234567891011[Route(\"[controller]\")] public class IdentityController : ControllerBase &#123; [HttpGet] [Authorize] public IActionResult Get() &#123; return new JsonResult(from c in HttpContext.User.Claims select new &#123; c.Type, c.Value &#125;); &#125; &#125;权限控制IdentityServer4 也提供了权限管理的功能，大概看了一眼，没有达到我想要（没耐心去研究）。我需要的是针对不同的模块，功能定义权限码（字符串），每个权限码对应相应的功能权限。当用户进行请求的时候，判断用户是否具备相应功能的权限（是否赋予了相应的权限字符串编码），来达到权限控制。IdentityServer的校验是通过Authorize特性来判断相应的Controller或Action是否需要校验。这里也通过自定义特性来实现权限的校验，并且是在原有的Authorize特性上进行扩展。可行的方案继承AuthorizeAttribute，重写。可是在.net core中提示没有OnAuthorization方法可进行重写。最后参考的ABP的做法，过滤器和特性共同使用。新建TestAuthorizationFilter.cs12345678910111213141516171819202122232425262728public class TestAuthorizationFilter : IAuthorizationFilter &#123; public void OnAuthorization(AuthorizationFilterContext context) &#123; if (context.Filters.Any(item =&gt; item is IAllowAnonymousFilter)) &#123; return; &#125; if (!(context.ActionDescriptor is ControllerActionDescriptor)) &#123; return; &#125; var attributeList = new List&lt;object&gt;(); attributeList.AddRange((context.ActionDescriptor as ControllerActionDescriptor).MethodInfo.GetCustomAttributes(true)); attributeList.AddRange((context.ActionDescriptor as ControllerActionDescriptor).MethodInfo.DeclaringType.GetCustomAttributes(true)); var authorizeAttributes = attributeList.OfType&lt;TestAuthorizeAttribute&gt;().ToList(); var claims = context.HttpContext.User.Claims; // 从claims取出用户相关信息，到数据库中取得用户具备的权限码，与当前Controller或Action标识的权限码做比较 var userPermissions = \"User_Edit\"; if (!authorizeAttributes.Any(s =&gt; s.Permission.Equals(userPermissions))) &#123; context.Result = new JsonResult(\"没有权限\"); &#125; return; &#125; &#125;新建TestAuthorizeAttribute123456789101112[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)] public class TestAuthorizeAttribute: AuthorizeAttribute &#123; public string Permission &#123; get; set; &#125; public TestAuthorizeAttribute(string permission) &#123; Permission = permission; &#125; &#125;将IdentityController [Authorize]改为[TestAuthorize(“User_Edit”)]，再运行API项目。通过修改权限码，验证是否起作用除了使用过滤器和特性结合使用，貌似还有别的方法，有空再研究。本文中的源码","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"https://jaycewu.site/tags/IdentityServer4/"},{"name":"Token","slug":"Token","permalink":"https://jaycewu.site/tags/Token/"},{"name":"权限控制","slug":"权限控制","permalink":"https://jaycewu.site/tags/权限控制/"}]},{"title":"利用AOP实现SqlSugar自动事务","slug":"利用AOP实现SqlSugar自动事务","date":"2017-10-25T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2017/10/25/利用AOP实现SqlSugar自动事务/","link":"","permalink":"https://jaycewu.site/2017/10/25/利用AOP实现SqlSugar自动事务/","excerpt":"","text":"先看一下效果,带接口层的三层架构:BL层：12345678910111213141516171819202122public class StudentBL : IStudentService &#123; private ILogger mLogger; private readonly IStudentDA mStudentDa; private readonly IValueService mValueService; public StudentService(IStudentDA studentDa,IValueService valueService) &#123; mLogger = LogManager.GetCurrentClassLogger(); mStudentDa = studentDa; mValueService = valueService; &#125; [TransactionCallHandler] public IList&lt;Student&gt; GetStudentList(Hashtable paramsHash) &#123; var list = mStudentDa.GetStudents(paramsHash); var value = mValueService.FindAll(); return list; &#125; &#125;假设GetStudentList方法里的mStudentDa.GetStudents和mValueService.FindAll不是查询操作，而是更新操作，当一个失败另一个需要回滚，就需要在同一个事务里，当一个出现异常就要回滚事务。特性TransactionCallHandler就表明当前方法需要开启事务，并且当出现异常的时候回滚事务,方法执行完后提交事务。DA层：12345678910111213public class StudentDA : IStudentDA &#123; private SqlSugarClient db; public StudentDA() &#123; db = SugarManager.GetInstance().SqlSugarClient; &#125; public IList&lt;Student&gt; GetStudents(Hashtable paramsHash) &#123; return db.Queryable&lt;Student&gt;().AS(\"T_Student\").With(SqlWith.NoLock).ToList(); &#125; &#125;对SqlSugar做一下包装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class SugarManager &#123; private static ConcurrentDictionary&lt;string,SqlClient&gt; _cache = new ConcurrentDictionary&lt;string, SqlClient&gt;(); private static ThreadLocal&lt;string&gt; _threadLocal; private static readonly string _connStr = @\"Data Source=localhost;port=3306;Initial Catalog=thy;user id=root;password=xxxxxx;Charset=utf8\"; static SugarManager() &#123; _threadLocal = new ThreadLocal&lt;string&gt;(); &#125; private static SqlSugarClient CreatInstance() &#123; SqlSugarClient client = new SqlSugarClient(new ConnectionConfig() &#123; ConnectionString = _connStr, //必填 DbType = DbType.MySql, //必填 IsAutoCloseConnection = true, //默认false InitKeyType = InitKeyType.SystemTable &#125;); var key=Guid.NewGuid().ToString().Replace(\"-\", \"\"); if (!_cache.ContainsKey(key)) &#123; _cache.TryAdd(key,new SqlClient(client)); _threadLocal.Value = key; return client; &#125; throw new Exception(\"创建SqlSugarClient失败\"); &#125; public static SqlClient GetInstance() &#123; var id= _threadLocal.Value; if (string.IsNullOrEmpty(id)||!_cache.ContainsKey(id)) return new SqlClient(CreatInstance()); return _cache[id]; &#125; public static void Release() &#123; try &#123; var id = GetId(); if (!_cache.ContainsKey(id)) return; Remove(id); &#125; catch (Exception e) &#123; throw e; &#125; &#125; private static bool Remove(string id) &#123; if (!_cache.ContainsKey(id)) return false; SqlClient client; int index = 0; bool result = false; while (!(result = _cache.TryRemove(id, out client))) &#123; index++; Thread.Sleep(20); if (index &gt; 3) break; &#125; return result; &#125; private static string GetId() &#123; var id = _threadLocal.Value; if (string.IsNullOrEmpty(id)) &#123; throw new Exception(\"内部错误: SqlSugarClient已丢失.\"); &#125; return id; &#125; public static void BeginTran() &#123; var instance=GetInstance(); //开启事务 if (!instance.IsBeginTran) &#123; instance.SqlSugarClient.Ado.BeginTran(); instance.IsBeginTran = true; &#125; &#125; public static void CommitTran() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误: SqlSugarClient已丢失.\"); if (_cache[id].TranCount == 0) &#123; _cache[id].SqlSugarClient.Ado.CommitTran(); _cache[id].IsBeginTran = false; &#125; &#125; public static void RollbackTran() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误: SqlSugarClient已丢失.\"); _cache[id].SqlSugarClient.Ado.RollbackTran(); _cache[id].IsBeginTran = false; _cache[id].TranCount = 0; &#125; public static void TranCountAddOne() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误: SqlSugarClient已丢失.\"); _cache[id].TranCount++; &#125; public static void TranCountMunisOne() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误: SqlSugarClient已丢失.\"); _cache[id].TranCount--; &#125; &#125;_cache保存SqlSugar实例，_threadLocal确保同一线程下取出的是同一个SqlSugar实例。不知道SqlSugar判断当前实例是否已经开启事务，所以又将SqlSugar包了一层。1234567891011public class SqlClient &#123; public SqlSugarClient SqlSugarClient; public bool IsBeginTran = false; public int TranCount = 0; public SqlClient(SqlSugarClient sqlSugarClient) &#123; this.SqlSugarClient = sqlSugarClient; &#125; &#125;IsBeginTran标识当前SqlSugar实例是否已经开启事务，TranCount是一个避免事务嵌套的计数器。一开始的例子1234567[TransactionCallHandler]public IList&lt;Student&gt; GetStudentList(Hashtable paramsHash)&#123; var list = mStudentDa.GetStudents(paramsHash); var value = mValueService.FindAll(); return list;&#125;TransactionCallHandler表明该方法要开启事务，但是如果mValueService.FindAll也标识了TransactionCallHandler,又要开启一次事务？所以用TranCount做一个计数。使用Castle.DynamicProxy要实现标识了TransactionCallHandler的方法实现自动事务，使用Castle.DynamicProxy实现BL类的代理Castle.DynamicProxy一般操作12345678910111213141516171819202122232425public class MyClass : IMyClass &#123; public void MyMethod() &#123; Console.WriteLine(\"My Mehod\"); &#125;&#125;public class TestIntercept : IInterceptor &#123; public void Intercept(IInvocation invocation) &#123; Console.WriteLine(\"before\"); invocation.Proceed(); Console.WriteLine(\"after\"); &#125; &#125; var proxyGenerate = new ProxyGenerator(); TestIntercept t=new TestIntercept(); var pg = proxyGenerate.CreateClassProxy&lt;MyClass&gt;(t); pg.MyMethod(); //输出是 //before //My Mehod //afterbefore就是要开启事务的地方，after就是提交事务的地方最后实现1234567891011121314151617181920212223242526272829303132333435363738394041public class TransactionInterceptor : IInterceptor &#123; private readonly ILogger logger; public TransactionInterceptor() &#123; logger = LogManager.GetCurrentClassLogger(); &#125; public void Intercept(IInvocation invocation) &#123; MethodInfo methodInfo = invocation.MethodInvocationTarget; if (methodInfo == null) &#123; methodInfo = invocation.Method; &#125; TransactionCallHandlerAttribute transaction = methodInfo.GetCustomAttributes&lt;TransactionCallHandlerAttribute&gt;(true).FirstOrDefault(); if (transaction != null) &#123; SugarManager.BeginTran(); try &#123; SugarManager.TranCountAddOne(); invocation.Proceed(); SugarManager.TranCountMunisOne(); SugarManager.CommitTran(); &#125; catch (Exception e) &#123; SugarManager.RollbackTran(); logger.Error(e); throw e; &#125; &#125; else &#123; invocation.Proceed(); &#125; &#125; &#125;12345678[AttributeUsage(AttributeTargets.Method, Inherited = true)]public class TransactionCallHandlerAttribute : Attribute&#123; public TransactionCallHandlerAttribute() &#123; &#125;&#125;Autofac与Castle.DynamicProxy结合使用创建代理的时候一个BL类就要一次操作1proxyGenerate.CreateClassProxy&lt;MyClass&gt;(t);而且项目里BL类的实例化是交给IOC容器控制的，我用的是Autofac。当然Autofac和Castle.DynamicProxy是可以结合使用的1234567891011121314using System.Reflection;using Autofac;using Autofac.Extras.DynamicProxy;using Module = Autofac.Module;public class BusinessModule : Module &#123; protected override void Load(ContainerBuilder builder) &#123; var business = Assembly.Load(\"FTY.Business\"); builder.RegisterAssemblyTypes(business) .AsImplementedInterfaces().InterceptedBy(typeof(TransactionInterceptor)).EnableInterfaceInterceptors(); builder.RegisterType&lt;TransactionInterceptor&gt;(); &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://jaycewu.site/tags/AOP/"},{"name":"SqlSugar","slug":"SqlSugar","permalink":"https://jaycewu.site/tags/SqlSugar/"},{"name":"事务","slug":"事务","permalink":"https://jaycewu.site/tags/事务/"},{"name":"Castle.DynamicProxy","slug":"Castle-DynamicProxy","permalink":"https://jaycewu.site/tags/Castle-DynamicProxy/"}]},{"title":"三种工厂模式与策略模式","slug":"三种工厂模式与策略模式","date":"2017-08-13T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/08/13/三种工厂模式与策略模式/","link":"","permalink":"https://jaycewu.site/2017/08/13/三种工厂模式与策略模式/","excerpt":"","text":"简单工厂模式实现一个功能，假设现在有跑车，越野车，商务车，想要开什么车的时候随时能发车。抽象汽车1234567/// &lt;summary&gt;/// 抽象汽车/// &lt;/summary&gt;public interface ICar&#123; void Run();&#125;汽车类型枚举123456public enum CarType&#123; SportCarType = 0, JeepCarType = 1, BusinessCarType = 2&#125;各种类型汽车实现1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 跑车/// &lt;/summary&gt;public class SportCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"跑车发车\"); &#125;&#125;/// &lt;summary&gt;/// 越野车/// &lt;/summary&gt;public class JeepCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"越野车发车\"); &#125;&#125;/// &lt;summary&gt;/// 商务车/// &lt;/summary&gt;public class BusinessCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"商务车发车\"); &#125;&#125;工厂类1234567891011121314151617public class Factory&#123; public ICar GetCar(CarType carType) &#123; switch (carType) &#123; case CarType.SportCarType: return new SportCar(); case CarType.JeepCarType: return new JeepCar(); case CarType.BusinessCarType: return new BusinessCar(); default: throw new Exception(\"翻车！\"); &#125; &#125;&#125;调用1234567891011class Program&#123; static void Main(string[] args) &#123; ICar car; Factory factory = new Factory(); Console.WriteLine(\"老司机跑车发车\"); car = factory.GetCar(CarType.SportCarType); car.Run(); &#125;&#125;优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。当要新增一个汽车类型的时候，只要实现指定接口就可以，符合开发关闭原则。缺点：很明显工厂类集中了所有实例的创建逻辑，当要加车类型的时候需要修改工厂类源码，违背开放关闭原则。工厂方法模式简单工厂的例子中，可以把工厂类看成汽车仓库，里面是已经生产好的汽车，想要什么类型的汽车，只要是已经生产好的就可以得到。现在我们想要开大卡车，但是仓库里没有，怎么办呢?我们换个高级点的仓库，一个可以生产大卡车的仓库，而且有很多这种仓库，每个仓库生产指定类型的汽车。抽象高级仓库1234public interface IFactory&#123; ICar CreateCar();&#125;抽象汽车1234567/// &lt;summary&gt;/// 抽象汽车/// &lt;/summary&gt;public interface ICar&#123; void Run();&#125;各种类型汽车实现12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 跑车/// &lt;/summary&gt;public class SportCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"跑车发车\"); &#125;&#125;/// &lt;summary&gt;/// 越野车/// &lt;/summary&gt;public class JeepCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"越野车发车\"); &#125;&#125;/// &lt;summary&gt;/// 商务车/// &lt;/summary&gt;public class BusinessCar : ICar&#123; public void Run() &#123; Console.WriteLine(\"商务车发车\"); &#125;&#125;/// &lt;summary&gt;/// 卡车/// &lt;/summary&gt;public class Truck : ICar&#123; public void Run() &#123; Console.WriteLine(\"卡车发车\"); &#125;&#125;具体高级仓库123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// 跑车仓库/// &lt;/summary&gt;public class SportFactory : IFactory&#123; public ICar CreateCar() &#123; return new SportCar(); &#125;&#125;/// &lt;summary&gt;/// 越野车仓库/// &lt;/summary&gt;public class JeepFactory : IFactory&#123; public ICar CreateCar() &#123; return new JeepCar(); &#125;&#125;/// &lt;summary&gt;/// 商务车仓库/// &lt;/summary&gt;public class BusinessCarFactory : IFactory&#123; public ICar CreateCar() &#123; return new BusinessCarCar(); &#125;&#125;/// &lt;summary&gt;/// 卡车仓库/// &lt;/summary&gt;public class TruckFactory : IFactory&#123; public ICar CreateCar() &#123; return new Truck(); &#125;&#125;调用123456789class Program &#123; static void Main(string[] args) &#123; IFactory factory = new TruckFactory(); ICar truck = factory.CreateCar(); truck.Run(); &#125; &#125;通过工厂方法模式，只要实现ICar接口，就可以创建一种新的类型的汽车，然后通过实现IFactory接口，创建一个可以生产这种新类型汽车的工厂。使用的时候，new一个新的工厂，就可以生产新类型的车了。抽象工厂模式汽车不仅有不同类型了，还有不同品牌的，比如跑车类型，有劳斯莱斯的,有宾利的，有迈凯伦的。。。假设，现在我们想开劳斯莱斯的跑车，我们的仓库怎么给我们车呢？或者说我们怎么从仓库把我们想要开的车拿到呢？工厂方法模式中我们通过实现仓库的多态，创建了很多可以具体生产某种类型汽车的工厂。现在通过实现汽车类型多态，具体的仓库（工厂）可以生产特定品牌不同类型的汽车，比如某个车库（工厂）可以生产宾利的跑车，商务车，越野车，卡车（滑稽）。抽象汽车1234567/// &lt;summary&gt;/// 抽象汽车/// &lt;/summary&gt;public interface ICar&#123; void Run();&#125;抽象汽车类型123456789/// &lt;summary&gt;/// 抽象跑车类型/// &lt;/summary&gt;public interface ISportCar:ICar&#123; //具体品牌名称 string Name&#123;get;&#125;&#125;//越野车，商务车类型类似（而且这里用抽象类更加合适）具体品牌的汽车类型123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 劳斯莱斯跑车/// &lt;/summary&gt;public class RollsRoyceSportCar:ISportCar&#123; //具体品牌名称 public string Name &#123; get&#123;return \"劳斯莱斯\";&#125; &#125; public void Run()&#123; Console.WriteLine(this.Name+\"跑车发车\"); &#125;&#125;/// &lt;summary&gt;/// 宾利跑车/// &lt;/summary&gt;public class BentleySportCar:ISportCar&#123; //具体品牌名称 public string Name &#123; get&#123;return \"宾利\";&#125; &#125; public void Run()&#123; Console.WriteLine(this.Name+\"跑车发车\"); &#125;&#125;...//越野车，商务车类型类似抽象车库（工厂）之前每个生产具体类型汽车的仓库（工厂）只要返回具体类型（实现ICar的汽车类）的汽车就可以，但是现在返回特定品牌的具体类型的汽车12345678public interface IFactory&#123; ISportCar CreateSportCar(); IJeepCar CreateJeepCar(); IJeepCar CreateJeepCar();&#125;具体工厂1234567891011121314151617/// &lt;summary&gt;/// 宾利工厂/// &lt;/summary&gt;public class BentleyFactory : IFactory&#123; public ISportCar CreateSportCar() &#123; return new BentleySportCar(); &#125; public IJeepCar CreateJeepCar()&#123; return new BentleyJeepCar(); &#125; ...&#125;//其它工厂类似调用12345678910class Program &#123; static void Main(string[] args) &#123; //开宾利跑车 IFactory factory = new BentleyFactory(); ISportCar bentleySportCar = factory.CreateSportCar(); bentleySportCar.Run(); &#125; &#125;当我们要新增一个新的类型的汽车，只要加一个继承ICar接口的新类型接口，然后在新类型下创建（实现新类型接口）具体品牌的汽车。但是要修改抽象工厂的源码，然后每个具体工厂的源码也要修改。在现有类型的车下新增品牌就很容易使用简单工厂减少具体工厂的数量，这样就可以不用去修改具体工厂的源码12345678910111213141516171819202122232425262728public class Factory&#123; public ISportCar CreateSportCar(string name) &#123; if(name==\"Bentley\") &#123; return new BentleySportCar(); &#125; if(name==\"RollsRoyce\") &#123; retutn new RollsRoyceSportCar(); &#125; ... &#125; public IJeepCar CreateJeepCar(string name) &#123; if(name==\"Bentley\") &#123; return new BentleyJeepCar(); &#125; if(name==\"RollsRoyce\") &#123; retutn new RollsRoyceJeepCar(); &#125; ... &#125; ...&#125;调用12345678910class Program &#123; static void Main(string[] args) &#123; //开宾利跑车 Factory factory = new Factory(); ISportCar bentleySportCar = factory.CreateSportCar(\"Bentley\"); bentleySportCar.Run(); &#125; &#125;还有更加方便的方法就是使用反射策略模式工厂模式是从工厂里new一个服务对象出来给客户使用，策略模式是客户注入一个具体实例对象给工厂以使用工厂提供的服务将上面的工厂改造一下123456789101112131415161718192021222324public class Factory &#123; private ISportCar sportCar; private IJeepCar jeepCar; ... public CreateSportCar(ISportCar sportCar) &#123; this.sportCar=sportCar; &#125; public CreateJeepCar(IJeepCar jeepCar) &#123; this.jeepCar=jeepCar; &#125; ... public void SportCarRun()&#123; &#123; this.sportCar.Run(); &#125; public void JeepCarRun()&#123; &#123; this.jeepCar.Run(); &#125; &#125;调用1234567891011class Program &#123; static void Main(string[] args) &#123; //开宾利跑车 ISportCar bentleySportCar = new BentleySportCar(); Factory factory=new Factory(); factory.CreateSportCar(bentleySportCar); factory.SportCarRun(); &#125; &#125;可能会因为注入的具体实现不同而得到不同的服务功能;","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://jaycewu.site/tags/工厂模式/"},{"name":"策略模式","slug":"策略模式","permalink":"https://jaycewu.site/tags/策略模式/"}]},{"title":"学习依赖注入与控制反转","slug":"学习依赖注入与控制反转","date":"2017-08-01T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2017/08/01/学习依赖注入与控制反转/","link":"","permalink":"https://jaycewu.site/2017/08/01/学习依赖注入与控制反转/","excerpt":"","text":"IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。IoC很好的体现了面向对象设计法则之一:由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。第一个例子一个叫IGame的游戏公司，正在开发一款ARPG游戏（动作&amp;角色扮演类游戏，如魔兽世界、梦幻西游这一类的游戏）。一般这类游戏都有一个基本的功能，就是打怪（玩家攻击怪物，借此获得经验、虚拟货币和虚拟装备），并且根据玩家角色所装备的武器不同，攻击效果也不同.打怪功能中的某一个功能:1、角色可向怪物实施攻击，一次攻击后，怪物掉部分HP，HP掉完后，怪物死亡。2、角色可装配不同武器，有木剑、铁剑、魔剑。3、木剑每次攻击，怪物掉20PH，铁剑掉50HP,魔剑掉100PH。一般实现HP当然是怪物的一个属性成员，而武器是角色的一个属性成员，类型可以使字符串，用于描述目前角色所装备的武器。角色类有一个攻击方法，以被攻击怪物为参数，当实施一次攻击时，攻击方法被调用，而这个方法首先判断当前角色装备了什么武器，然后据此对被攻击怪物的HP进行操作，以产生不同效果。1234567891011121314151617181920212223242526272829using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLi&#123; /// &lt;summary&gt; /// 怪物 /// &lt;/summary&gt; internal sealed class Monster &#123; /// &lt;summary&gt; /// 怪物的名字 /// &lt;/summary&gt; public String Name &#123; get; set; &#125; /// &lt;summary&gt; /// 怪物的生命值 /// &lt;/summary&gt; public Int32 HP &#123; get; set; &#125; public Monster(String name,Int32 hp) &#123; this.Name = name; this.HP = hp; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLi&#123; /// &lt;summary&gt; /// 角色 /// &lt;/summary&gt; internal sealed class Role &#123; private Random _random = new Random(); /// &lt;summary&gt; /// 表示角色目前所持武器的字符串 /// &lt;/summary&gt; public String WeaponTag &#123; get; set; &#125; /// &lt;summary&gt; /// 攻击怪物 /// &lt;/summary&gt; /// &lt;param name=\"monster\"&gt;被攻击的怪物&lt;/param&gt; public void Attack(Monster monster) &#123; if (monster.HP &lt;= 0) &#123; Console.WriteLine(\"此怪物已死\"); return; &#125; if (\"WoodSword\" == this.WeaponTag) &#123; monster.HP -= 20; if (monster.HP &lt;= 0) &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"已死亡\"); &#125; else &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"损失20HP\"); &#125; &#125; else if (\"IronSword\" == this.WeaponTag) &#123; monster.HP -= 50; if (monster.HP &lt;= 0) &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"已死亡\"); &#125; else &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"损失50HP\"); &#125; &#125; else if (\"MagicSword\" == this.WeaponTag) &#123; Int32 loss = (_random.NextDouble() &lt; 0.5) ? 100 : 200; monster.HP -= loss; if (200 == loss) &#123; Console.WriteLine(\"出现暴击！！！\"); &#125; if (monster.HP &lt;= 0) &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"已死亡\"); &#125; else &#123; Console.WriteLine(\"攻击成功！怪物\" + monster.Name + \"损失\" + loss + \"HP\"); &#125; &#125; else &#123; Console.WriteLine(\"角色手里没有武器，无法攻击！\"); &#125; &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLi&#123; class Program &#123; static void Main(string[] args) &#123; //生成怪物 Monster monster1 = new Monster(\"小怪A\", 50); Monster monster2 = new Monster(\"小怪B\", 50); Monster monster3 = new Monster(\"关主\", 200); Monster monster4 = new Monster(\"最终Boss\", 1000); //生成角色 Role role = new Role(); //木剑攻击 role.WeaponTag = \"WoodSword\"; role.Attack(monster1); //铁剑攻击 role.WeaponTag = \"IronSword\"; role.Attack(monster2); role.Attack(monster3); //魔剑攻击 role.WeaponTag = \"MagicSword\"; role.Attack(monster3); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); Console.ReadLine(); &#125; &#125;&#125;存在问题:Role类的Attack方法很长，并且方法中有一个冗长的if…else结构，且每个分支的代码的业务逻辑很相似，只是很少的地方不同违反了OCP原则。在这个设计中，如果以后我们增加一个新的武器，如倚天剑，每次攻击损失500HP，那么，我们就要打开Role，修改Attack方法。而我们的代码应该是对修改关闭的，当有新武器加入的时候，应该使用扩展完成，避免修改已有代码。一般来说，当一个方法里面出现冗长的if…else或switch…case结构，且每个分支代码业务相似时，往往预示这里应该引入多态性来解决问题。而这里，如果把不同武器攻击看成一个策略，那么引入策略模式（Strategy Pattern）是明智的选择。最后说一个小的问题，被攻击后，减HP、死亡判断等都是怪物的职责，这里放在Role中有些不当Tip：OCP原则，即开放关闭原则，指设计应该对扩展开放，对修改关闭。Tip：策略模式，英文名Strategy Pattern，指定义算法族，分别封装起来，让他们之间可以相互替换，此模式使得算法的变化独立于客户。第二种实现123456789101112using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; internal interface IAttackStrategy &#123; void AttackTarget(Monster monster); &#125;&#125;123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; internal sealed class WoodSword : IAttackStrategy &#123; public void AttackTarget(Monster monster) &#123; monster.Notify(20); &#125; &#125;&#125;123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; internal sealed class IronSword : IAttackStrategy &#123; public void AttackTarget(Monster monster) &#123; monster.Notify(50); &#125; &#125;&#125;12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; internal sealed class MagicSword : IAttackStrategy &#123; private Random _random = new Random(); public void AttackTarget(Monster monster) &#123; Int32 loss = (_random.NextDouble() &lt; 0.5) ? 100 : 200; if (200 == loss) &#123; Console.WriteLine(\"出现暴击！！！\"); &#125; monster.Notify(loss); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; /// &lt;summary&gt; /// 怪物 /// &lt;/summary&gt; internal sealed class Monster &#123; /// &lt;summary&gt; /// 怪物的名字 /// &lt;/summary&gt; public String Name &#123; get; set; &#125; /// &lt;summary&gt; /// 怪物的生命值 /// &lt;/summary&gt; private Int32 HP &#123; get; set; &#125; public Monster(String name,Int32 hp) &#123; this.Name = name; this.HP = hp; &#125; /// &lt;summary&gt; /// 怪物被攻击时，被调用的方法，用来处理被攻击后的状态更改 /// &lt;/summary&gt; /// &lt;param name=\"loss\"&gt;此次攻击损失的HP&lt;/param&gt; public void Notify(Int32 loss) &#123; if (this.HP &lt;= 0) &#123; Console.WriteLine(\"此怪物已死\"); return; &#125; this.HP -= loss; if (this.HP &lt;= 0) &#123; Console.WriteLine(\"怪物\" + this.Name + \"被打死\"); &#125; else &#123; Console.WriteLine(\"怪物\" + this.Name + \"损失\" + loss + \"HP\"); &#125; &#125; &#125;&#125;123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; /// &lt;summary&gt; /// 角色 /// &lt;/summary&gt; internal sealed class Role &#123; /// &lt;summary&gt; /// 表示角色目前所持武器 /// &lt;/summary&gt; public IAttackStrategy Weapon &#123; get; set; &#125; /// &lt;summary&gt; /// 攻击怪物 /// &lt;/summary&gt; /// &lt;param name=\"monster\"&gt;被攻击的怪物&lt;/param&gt; public void Attack(Monster monster) &#123; this.Weapon.AttackTarget(monster); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text; namespace IGameLiAdv&#123; class Program &#123; static void Main(string[] args) &#123; //生成怪物 Monster monster1 = new Monster(\"小怪A\", 50); Monster monster2 = new Monster(\"小怪B\", 50); Monster monster3 = new Monster(\"关主\", 200); Monster monster4 = new Monster(\"最终Boss\", 1000); //生成角色 Role role = new Role(); //木剑攻击 role.Weapon = new WoodSword(); role.Attack(monster1); //铁剑攻击 role.Weapon = new IronSword(); role.Attack(monster2); role.Attack(monster3); //魔剑攻击 role.Weapon = new MagicSword(); role.Attack(monster3); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); role.Attack(monster4); Console.ReadLine(); &#125; &#125;&#125;优点：第一，虽然类的数量增加了，但是每个类中方法的代码都非常短，没有了以前Attack方法那种很长的方法，也没有了冗长的if…else，代码结构变得很清晰。第二，类的职责更明确了。在第一个设计中，Role不但负责攻击，还负责给怪物减少HP和判断怪物是否已死。这明显不应该是Role的职责，改进后的代码将这两个职责移入Monster内，使得职责明确，提高了类的内聚性。第三，引入Strategy模式后，不但消除了重复性代码，更重要的是，使得设计符合了OCP。如果以后要加一个新武器，只要新建一个类，实现IAttackStrategy接口，当角色需要装备这个新武器时，客户代码只要实例化一个新武器类，并赋给Role的Weapon成员就可以了，已有的Role和Monster代码都不用改动。这样就实现了对扩展开发，对修改关闭。初窥依赖注入上面例子的第二种实现中，Role不依赖具体武器，而仅仅依赖一个IAttackStrategy接口，接口是不能实例化的，虽然Role的Weapon成员类型定义为IAttackStrategy，但最终还是会被赋予一个实现了IAttackStrategy接口的具体武器，并且随着程序进展，一个角色会装备不同的武器，从而产生不同的效用。赋予武器的职责，在Demo中是放在了测试代码里。这里，测试代码实例化一个具体的武器，并赋给Role的Weapon成员的过程，就是依赖注入！这里要清楚，依赖注入其实是一个过程的称谓！依赖注入产生的背景：随着面向对象分析与设计的发展，一个良好的设计，核心原则之一就是将变化隔离，使得变化部分发生变化时，不变部分不受影响（这也是OCP的目的）。为了做到这一点，要利用面向对象中的多态性，使用多态性后，客户类不再直接依赖服务类，而是依赖于一个抽象的接口，这样，客户类就不能在内部直接实例化具体的服务类。但是，客户类在运作中又客观需要具体的服务类提供服务，因为接口是不能实例化去提供服务的。就产生了“客户类不准实例化具体服务类”和“客户类需要具体服务类”这样一对矛盾。为了解决这个矛盾，开发人员提出了一种模式：客户类（如上例中的Role）定义一个注入点（Public成员Weapon），用于服务类（实现IAttackStrategy的具体类，如WoodSword、IronSword和MagicSword，也包括以后加进来的所有实现IAttackStrategy的新类）的注入，而客户类的客户类（Program，即测试代码）负责根据情况，实例化服务类，注入到客户类中，从而解决了这个矛盾。依赖注入的正式定义：依赖注入（Dependency Injection），是这样一个过程：由于某客户类只依赖于服务类的一个接口，而不依赖于具体服务类，所以客户类只定义一个注入点。在程序运行过程中，客户类不直接实例化具体服务类实例，而是客户类的运行上下文环境或专门组件负责实例化服务类，然后将其注入到客户类中，保证客户类的正常运行。依赖注入的类别依赖注入有很多种方法，上面看到的例子中，只是其中的一种，下面从另一个例子了解不同的依赖注入类型。第二个例子《墨攻》这部电影讲述了战国时期墨家人革离帮助梁国反抗赵国侵略的个人英雄主义故事，恢宏壮阔，浑雄凝重的历史场面相当震撼。其中有一个场景：当刘德华所饰的墨者革离到达梁国都城下，城上梁国守军问：“来者何人？”，刘德华回答：“墨者革离！”，对这段“城门问对”的场景进行编剧并借由这个例子来理解IoC的内涵。剧本与演员直接耦合MoAttack代表《墨攻》的剧本，CityGetAsk()代表“城门问对”这段剧情，LiuDeHua是具体饰演者刘德华1234567public class LiuDeHua&#123; public void ResponseAsk(string res) &#123; Console.WriteLine(res); &#125;&#125;123456789101112131415public class MoAttack &#123; public MoAttack() &#123; &#125; public void CityGateAsk() &#123; LiuDeHua ldh = new LiuDeHua();//演员直接侵入剧本 ldh.ResponseAsk(\"墨者革离！\"); &#125; &#125;我们会发现,作为具体饰演者的刘德华直接侵入到剧本中，使剧本和演员直接耦合在一起引入剧本角色一个明智的编剧在剧情创作时应围绕故事的角色进行，而不应考虑角色的具体饰演者，这样才可能在剧本投拍时自由地选择任何适合的演员，而非绑定在刘德华一人身上。通过以上的分析，我们知道需要为该剧本主人公革离定义一个接口，以角色进行剧情安排，饰演者实现角色的接口.添加革离角色接口1234public interface IGeLi &#123; void ResponseAsk(string res); &#125;饰演者实现接口1234567public class LiuDeHua:IGeLi &#123; public void ResponseAsk(string res) &#123; Console.WriteLine(res); &#125; &#125;剧本123456789101112131415public class MoAttack &#123; public MoAttack() &#123; &#125; public void CityGateAsk() &#123; IGeLi ldh = new LiuDeHua(); ldh.ResponseAsk(&quot;墨者革离！&quot;); &#125; &#125;剧本和饰演者解耦我们希望剧本和演员无关，可是即使加入了剧本角色，我们看到MoAttack同时依赖于IGeLi接口和LiuDeHua类，并没有达到我们所期望的剧本仅依赖于角色的目的。可是角色最终又必须通过具体的演员才能完成拍摄，如何将让LiuDeHua和剧本无关而又能完成IGeLi的具体动作呢？当然是在影片投拍时，导演将LiuDeHua安排在GeLi的角色上，通过导演之手将剧本、角色、饰演者装配起来。构造函数注入新的MoAttack1234567891011121314151617public class MoAttack &#123; private IGeLi geli; public MoAttack(IGeLi geli)//注入革离的具体扮演者 &#123; this.geli = geli; &#125; public void CityGateAsk() &#123; this.geli.ResponseAsk(\"墨者革离！\"); &#125; &#125;MoAttack的构造函数不关心具体是谁扮演革离这个角色，只要传入的扮演者按剧本要求完成角色功能即可角色的具体扮演者由导演来安排:12345678910111213public class Director &#123; public void direct() &#123; IGeLi geli = new LiuDeHua(); //指定角色的扮演者 MoAttack moAttack = new MoAttack(geli); //注入具体扮演者到剧本中 moAttack.CityGateAsk(); &#125; &#125;属性注入有时，导演会发现，虽然革离是影片《墨攻》的第一主人公，但并非每场戏都需要革离的出现，通过构造函数方式注入显得很不妥当，在这种情况下，可以使用属性注入进行改造。1234567891011121314151617public class MoAttack &#123; private IGeLi geli; public IGeLi GeLi //属性注入方法 &#123; set &#123; this.geli=value;&#125; &#125; public void CityGateAsk() &#123; this.geli.ResponseAsk(\"墨者革离！\"); &#125; &#125;123456789101112131415public class Director &#123; public void direct() &#123; IGeLi geli = new LiuDeHua(); //指定角色的扮演者 MoAttack moAttack = new MoAttack(); moAttack.GeLi = geli;//调用属性注入 moAttack.CityGateAsk(); &#125; &#125;MoAttack在geli 字段提供一个属性，以便让导演在拍需要革离的戏时才将geli的具体扮演者注入，而不需要刘德华从头到尾跟着墨攻剧组跑和通过构造函数注入革离扮演者不同，在实例化MoAttack时，并未指定任何扮演者，而是在实例化MoAttack后，调用其属性注入扮演者。按照类似的方式，我们还可以为剧本中其他如巷淹中，梁王等角色分别提供注入的属性，导演即可以根据所拍剧段的不同，注入所需要的角色了。接口注入将客户类所有注入的方法抽取到一个接口中，客户类通过实现这一接口提供注入的方法。为了采取接口注入的方式，需要声明一个额外的接口：1234public interface IActorArrangable &#123; void InjectGeli(IGeLi geli); &#125;MoAttack实现这个接口并实现接口中的方法：12345678910111213141516public class MoAttack : IActorArrangable &#123; private IGeLi geli; public void CityGateAsk() &#123; this.geli.ResponseAsk(\"墨者革离！\"); &#125; public void InjectGeli(IGeLi geli) &#123; this.geli = geli; &#125; &#125;Director通过IActorArrangable接口的injectGeli()方法完成扮演者的注入工作123456789101112131415public class Director &#123; public void direct() &#123; IGeLi geli = new LiuDeHua(); //指定角色的扮演者 MoAttack moAttack = new MoAttack(); moAttack.InjectGeli(geli); moAttack.CityGateAsk(); &#125; &#125;由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，因此我们不提倡这种方式通过容器完成依赖关系的建立虽然MoAttack和LiuDeHua实现了解耦，无需关注实现类的实例化工作，但这些工作在代码中依然存在，只是转移到Director中而已，导致导演的权力非常大，潜规则不断滋生。假设某一制片人想改变这一局面，在相中某个剧本后，通过一个“海选”或者第三公正中介来选择导演、演员，让他们各司其职，那剧本、导演、演员就都实现解耦了。所谓媒体“海选”和中介机构在程序领域即是一个第三方容器，它帮助我们完成类的初始化和装配工作，让我们从这些底层的实现类实例化，依赖关系的装配中脱离出来，专注于更有意思的业务代码的编写工作，那确实是挺惬意的事情。Spring.Net就是这样一个容器，它通过配置文件描述类之间的依赖关系，下面是Spring.Net配置文件的对以上实例进行配置的样式代码：1234567891011&lt;objects&gt; &lt;object id=\"geli\" type=\"RuoXie.IOCTest.LiuDeHua\"&gt;&lt;/object&gt; &lt;object id=\"moAttack\" type=\"RuoXie.IOCTest.MoAttack\"&gt; &lt;property name=\"geli\"&gt;&lt;ref=\"geli\"/&gt;&lt;/property&gt; &lt;/object&gt;&lt;/objects&gt;参考文档：依赖注入那些事儿墨攻IOC","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"https://jaycewu.site/tags/IOC/"},{"name":"DI","slug":"DI","permalink":"https://jaycewu.site/tags/DI/"},{"name":"依赖注入","slug":"依赖注入","permalink":"https://jaycewu.site/tags/依赖注入/"},{"name":"控制反转","slug":"控制反转","permalink":"https://jaycewu.site/tags/控制反转/"}]},{"title":"将数据库事务从dao层提升到service层","slug":"将数据库事务从dao层提升到service层","date":"2017-07-30T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2017/07/30/将数据库事务从dao层提升到service层/","link":"","permalink":"https://jaycewu.site/2017/07/30/将数据库事务从dao层提升到service层/","excerpt":"","text":"学习后端语言的时候，都会涉及到数据库的相关操作，不同语言在操作数据库方面有不同的驱动程序，比如java的JDBC,C#的ADO.NET。当进行数据的新增，更新以及删除的时候，经常需要开启数据库事务。比如ADO.NET是这样使用：123456789101112131415SqlConnection con = new Sqlconnection(\"数据库连接语句\");con.Open();var trans = con.BeginTransaction();try&#123; SqlCommand com = new SqlCommand(trans); //处理插入或更新逻辑 trans.Commit();&#125;catch(ex)&#123; trans.Rollback();//如果前面有异常则事务回滚&#125;finally&#123; con.Close();&#125;很多教程都将事务写在数据访问层(dao层)，但是更多时候我们需要的是业务逻辑层(service层)级别的事务控制。比如我们有一个学生表，一个班级表。学生表存有对应的班级字段，学生与班级表都有对应的dao和service操作类。每个dao只操作相关的数据，不能即操作学生的数据，又操作班级的数据。现在我们要删除一个班级，并且将该班级的学生一并删除。不管是先删除班级还是先删除学生(不存在外键约束)，反正就是要一起删除。因为每个dao只操作单一的对象，这时候dao中进行删除操作的时候开启事务是达不到我们目的。班级删除失败，学生的删除操作是不会回滚的，反之也一样。删除班级的同时一并删除学生，某一个失败，另一个删除操作回滚。这属于一个业务层的原子操作。在班级的service操作类中可以引入班级和学生的dao进行操作，两个dao的操作放到同一事务中进行操作。连接Id类1234567891011121314151617181920212223namespace RuoXieTranscation&#123; public class ConnId &#123; private string _cconId = Guid.NewGuid().ToString().Replace(\"-\", \"\"); private DateTime _createTime=DateTime.Now; public ConnId() &#123; &#125; public string CconId &#123; get &#123; return _cconId; &#125; &#125; public DateTime CreateTime &#123; get &#123; return _createTime; &#125; &#125; &#125;&#125;生成一个guid，后面标识每个连接实例的唯一性。连接类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106namespace RuoXieTranscation&#123; public class DbConnection &#123; private string _sConnStr = \"\"; private ConnId _connId = null; private SqlConnection _sqlConnection = null; private SqlCommand _sqlCommand = null; public ConnId ConnId &#123; get &#123; return _connId; &#125; &#125; public SqlCommand SqlCommand &#123; get &#123; return _sqlCommand; &#125; &#125; public DbConnection(string connStr) &#123; _sConnStr = connStr; &#125; public ConnId ConnOpen() &#123; try &#123; this._sqlConnection = new SqlConnection(_sConnStr); this._sqlCommand = new SqlCommand(); _sqlCommand.Connection = this._sqlConnection; this._connId = new ConnId(); _sqlConnection.Open(); &#125; catch (Exception e) &#123; if (this._sqlConnection.State != System.Data.ConnectionState.Closed) &#123; this._sqlConnection.Close(); this._sqlConnection.Dispose(); &#125; this._sqlConnection = null; &#125; return this._connId; &#125; public void BeginTransaction() &#123; try &#123; _sqlCommand.Transaction = _sqlConnection.BeginTransaction(System.Data.IsolationLevel.ReadCommitted, this._connId.CconId); &#125; catch (Exception e) &#123; if (this._sqlConnection.State != System.Data.ConnectionState.Closed) &#123; this._sqlConnection.Close(); this._sqlConnection.Dispose(); &#125; this._sqlConnection = null; &#125; &#125; public void Commit() &#123; try &#123; this._sqlCommand.Transaction.Commit(); &#125; catch (Exception e) &#123; this._sqlCommand.Transaction.Rollback(); &#125; &#125; public void Rollback() &#123; try &#123; this._sqlCommand.Transaction.Rollback(); &#125; catch (Exception e) &#123; this._sqlCommand.Transaction.Rollback(); &#125; &#125; public void Close() &#123; if (this._sqlCommand != null) &#123; this._sqlCommand.Dispose(); &#125; if (this._sqlConnection.State != System.Data.ConnectionState.Closed) &#123; this._sqlConnection.Close(); this._sqlConnection.Dispose(); &#125; &#125; &#125;&#125;打开连接后可以显式调用BeginTransaction来决定使用事务连接管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118namespace RuoXieTranscation&#123; public class ConnManager &#123; private static ConcurrentDictionary&lt;string, DbConnection&gt; _cache = new ConcurrentDictionary&lt;string, DbConnection&gt;(); private static ThreadLocal&lt;string&gt; _threadLocal; private static readonly string _connStr = @\"Password=977865769;Persist Security Info=True;User ID=sa;Initial Catalog=RuoXie;Data Source=5ENALIZN94GYJZZ\\SQLEXPRESS\"; static ConnManager() &#123; _threadLocal=new ThreadLocal&lt;string&gt;(); &#125; public static bool CreateConn() &#123; DbConnection dbconn = new DbConnection(_connStr); ConnId key = dbconn.ConnOpen(); if (!_cache.ContainsKey(key.CconId)) &#123; _cache.TryAdd(key.CconId, dbconn); _threadLocal.Value = key.CconId; Console.WriteLine(\"创建数据库连接,Id: \" + key.CconId); return true; &#125; throw new Exception(\"打开数据库连接失败\"); &#125; public static void BeginTransaction() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误，链接已丢失\"); _cache[id].BeginTransaction(); &#125; public static void Commit() &#123; try &#123; var id = GetId(); if(!_cache.ContainsKey(id)) throw new Exception(\"内部错误，链接已丢失\"); _cache[id].Commit(); &#125; catch (Exception e) &#123; throw e; &#125; &#125; public static void Rollback() &#123; try &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误，链接已丢失\"); _cache[id].Rollback(); &#125; catch (Exception e) &#123; throw e; &#125; &#125; public static void ReleaseConn() &#123; try &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误，链接已丢失\"); _cache[id].Close(); Remove(id); &#125; catch (Exception e) &#123; throw e; &#125; &#125; public static SqlCommand GetSqlCommand() &#123; var id = GetId(); if (!_cache.ContainsKey(id)) throw new Exception(\"内部错误: 连接已丢失.\"); return _cache[id].SqlCommand; &#125; private static string GetId() &#123; var id = _threadLocal.Value; if (string.IsNullOrEmpty(id)) &#123; throw new Exception(\"内部错误: 连接已丢失.\"); &#125; return id; &#125; private static bool Remove(string id) &#123; if (!_cache.ContainsKey(id)) return false; DbConnection dbConnection; int index = 0; bool result = false; while (!(result = _cache.TryRemove(id, out dbConnection))) &#123; index++; Thread.Sleep(20); if (index &gt; 3) break; &#125; return result; &#125; &#125;&#125;通过静态属性_cache保存每个连接的Id,_threadLocal保存当前线程中的连接Id，不管一个service中涉及多少个dao操作，都是处于同一线程中，通过_threadLocal就可以取出同一个连接对象进行操作。使用12345678910111213141516171819202122232425262728public class SQLHelper &#123; public static int ExecuteNonQuery(string sql, SqlParameter[] parameters = null) &#123; var command = ConnManager.GetSqlCommand(); command.CommandText = sql; command.CommandType = System.Data.CommandType.Text; if (parameters != null) &#123; command.Parameters.Clear(); command.Parameters.AddRange(parameters); &#125; return command.ExecuteNonQuery(); &#125; public static object ExecuteScalar(string sql, SqlParameter[] parameters = null) &#123; var command = ConnManager.GetSqlCommand(); command.CommandText = sql; command.CommandType = System.Data.CommandType.Text; if (parameters != null) &#123; command.Parameters.Clear(); command.Parameters.AddRange(parameters); &#125; return command.ExecuteScalar(); &#125; &#125;123456789101112131415public class StudentDao &#123; public bool Add(string name, string no) &#123; string sql = string.Format(\"insert into T_Student(Name12,No) values(@name,@no)\"); var nameParameter = new SqlParameter(\"@name\", SqlDbType.NVarChar); var noParameter = new SqlParameter(\"@no\", SqlDbType.NVarChar); nameParameter.Value = name; noParameter.Value = no; SqlParameter[] paras = new SqlParameter[]&#123; nameParameter,noParameter &#125;; return SQLHelper.ExecuteNonQuery(sql, paras) &gt; 0; &#125; &#125;1234567891011121314public class StudentBll &#123; private StudentDao mDao; public StudentBll() &#123; mDao=new StudentDao(); &#125; public bool AddStudent(string name, string no) &#123; return mDao.Add(name, no); &#125; &#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Program &#123; static void Main(string[] args) &#123; test(); test2(); test3(); Console.ReadLine(); &#125; static void test() &#123; ConnManager.CreateConn(); ConnManager.BeginTransaction(); try &#123; var classService = new ClassBll(); classService.AddClass(\"7班\"); ConnManager.Commit(); ConnManager.ReleaseConn(); &#125; catch (Exception e) &#123; ConnManager.Rollback(); ConnManager.ReleaseConn(); &#125; &#125; static void test2() &#123; ConnManager.CreateConn(); ConnManager.BeginTransaction(); try &#123; var classService = new ClassBll(); var studentService=new StudentBll(); classService.AddClass(\"8班\"); studentService.AddStudent(\"李四\",\"001\"); ConnManager.Commit(); ConnManager.ReleaseConn(); &#125; catch (Exception e) &#123; ConnManager.Rollback(); ConnManager.ReleaseConn(); &#125; &#125; static void test3() &#123; ConnManager.CreateConn(); //ConnManager.BeginTransaction(); try &#123; var classService = new ClassBll(); var studentService = new StudentBll(); classService.AddClass(\"8班\"); studentService.AddStudent(\"李四\", \"001\"); //ConnManager.Commit(); ConnManager.ReleaseConn(); &#125; catch (Exception e) &#123; //ConnManager.Rollback(); ConnManager.ReleaseConn(); &#125; &#125; &#125;虽然将事务提取到了service层，但是每次都要写这样的代码12345678910111213ConnManager.CreateConn();ConnManager.BeginTransaction();try&#123; //业务逻辑调用 ConnManager.Commit(); ConnManager.ReleaseConn();&#125;catch (Exception e)&#123; ConnManager.Rollback(); ConnManager.ReleaseConn();&#125;使用过spring或者spring.net的应该都知道将事务控制转到业务层事多简单，比如spring.net123456[Transaction]public void DeleteData(string name)&#123; UserDao.Delete(name); AccountDao.Delete(name);&#125;只需要在service方法加上Transaction attribute。原理就是AOP编程。","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://jaycewu.site/tags/C/"},{"name":"数据库事务","slug":"数据库事务","permalink":"https://jaycewu.site/tags/数据库事务/"}]},{"title":"CSS实现Tab布局","slug":"CSS实现Tab布局","date":"2017-04-05T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/04/05/CSS实现Tab布局/","link":"","permalink":"https://jaycewu.site/2017/04/05/CSS实现Tab布局/","excerpt":"","text":"一、布局方式1、内容与tab分离12345678910111213141516&lt;div class=\"container\"&gt; &lt;div class=\"tab-content\"&gt; &lt;div id=\"item1\" class=\"item\"&gt;内容1&lt;/div&gt; &lt;div id=\"item2\" class=\"item\"&gt;内容2&lt;/div&gt; &lt;div id=\"item3\" class=\"item\"&gt;内容3&lt;/div&gt; &lt;div id=\"item4\" class=\"item\"&gt;内容4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"tab-control\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#item1\"&gt;内容1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item2\"&gt;内容2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item3\"&gt;内容3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item4\"&gt;内容4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ul,li&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver;&#125;.tab-content&#123; width:100%; height:80%; overflow:hidden;&#125;.tab-content .item&#123; width:100%; height:100%;&#125;.tab-control&#123; width:100%; height:20%;&#125;.tab-control ul&#123; height:100%;&#125;.tab-control li&#123; width:25%; height:100%; float:left; border:1px solid silver; box-sizing:border-box; background-color:white; cursor: pointer;&#125;.tab-control li:hover&#123; background-color:#7b7474&#125;.tab-control a&#123; display:inline-block; width:100%; height:100%; line-height:100%; text-align:center; text-decoration: none;&#125;.tab-control a::after&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle;&#125;.tab-content .item:target&#123; background:yellow;&#125;2、内容与tab一体1234567891011121314151617181920&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"item active\"&gt; &lt;p class=\"title\"&gt;1&lt;/p&gt; &lt;p class=\"content\"&gt;1&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;2&lt;/p&gt; &lt;p class=\"content ml1\"&gt;2&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;3&lt;/p&gt; &lt;p class=\"content ml2\"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;4&lt;/p&gt; &lt;p class=\"content ml3\"&gt;4&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ul,li,p&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver; border:1px solid silver;&#125;.container ul&#123; width:100%; height:100%; overflow:hidden;&#125;.container .item&#123; float:left; width:25%; height:100%; background-color:white;&#125;.container .item .title&#123; line-height:40px; border:1px solid silver; box-sizing:border-box; text-align:center; cursor:pointer;&#125;.container .item .content&#123; width:400%; height:100%; background-color:yellow;&#125;.ml1&#123; margin-left:-100%;&#125;.ml2&#123; margin-left:-200%;&#125;.ml3&#123; margin-left:-300%;&#125;.active&#123; position:relative; z-index:1&#125;.container .item:hover&#123; position:relative; z-index:1&#125;.container .item:hover .title&#123; border-bottom:none; background-color:yellow;&#125;利用负margin，将内容区对齐，然后内容去添加背景色，避免不同tab对应的区域透视重叠。二、CSS实现交互1、锚点实现（target）(1)针对布局一：item从上往下排列，父元素tab-content加上overflow:hidden。利用锚点，点击不同a标签的时候，具有对应ID的item会切换到tab-content的视图中，然后利用hover给tab按钮加上切换样式。12345678910111213141516&lt;div class=\"container\"&gt; &lt;div class=\"tab-content\"&gt; &lt;div id=\"item1\" class=\"item\"&gt;内容1&lt;/div&gt; &lt;div id=\"item2\" class=\"item\"&gt;内容2&lt;/div&gt; &lt;div id=\"item3\" class=\"item\"&gt;内容3&lt;/div&gt; &lt;div id=\"item4\" class=\"item\"&gt;内容4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"tab-control\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#item1\"&gt;内容1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item2\"&gt;内容2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item3\"&gt;内容3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#item4\"&gt;内容4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ul,li&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver;&#125;.tab-content&#123; width:100%; height:80%; overflow:hidden;&#125;.tab-content .item&#123; width:100%; height:100%;&#125;.tab-control&#123; width:100%; height:20%;&#125;.tab-control ul&#123; height:100%;&#125;.tab-control li&#123; width:25%; height:100%; float:left; border:1px solid silver; box-sizing:border-box; background-color:white; cursor: pointer;&#125;.tab-control li:hover&#123; background-color:#7b7474&#125;.tab-control a&#123; display:inline-block; width:100%; height:100%; line-height:100%; text-align:center; text-decoration: none;&#125;.tab-control a::after&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle;&#125;上述方法只是利用了锚点切换，没有使用：target。修改CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061ul,li&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver;&#125;.tab-content&#123; position:relative; width:100%; height:80%; overflow:hidden;&#125;.tab-content .item&#123; position:absolute; left:0; top:0; width:100%; height:100%;&#125;.tab-control&#123; width:100%; height:20%;&#125;.tab-control ul&#123; height:100%;&#125;.tab-control li&#123; width:25%; height:100%; float:left; border:1px solid silver; box-sizing:border-box; background-color:white; cursor: pointer;&#125;.tab-control li:hover&#123; background-color:#7b7474&#125;.tab-control a&#123; display:inline-block; width:100%; height:100%; line-height:100%; text-align:center; text-decoration: none;&#125;.tab-control a::after&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle;&#125;.tab-content .item:target&#123; z-index:1; background-color:yellow;&#125;item使用绝对定位，然后使用:target修改元素z-index达到切换效果（其实也可以通过控制元素的display来达到切换效果）（2）针对布局二：1234567891011121314151617181920&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"item active\" id=\"item1\"&gt; &lt;p class=\"title\"&gt;&lt;a href=\"#item1\"&gt;1&lt;/a&gt;&lt;/p&gt; &lt;p class=\"content\"&gt;1&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\" id=\"item2\"&gt; &lt;p class=\"title\"&gt;&lt;a href=\"#item2\"&gt;2&lt;/a&gt;&lt;/p&gt; &lt;p class=\"content ml1\"&gt;2&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\" id=\"item3\"&gt; &lt;p class=\"title\"&gt;&lt;a href=\"#item3\"&gt;3&lt;/a&gt;&lt;/p&gt; &lt;p class=\"content ml2\"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\" id=\"item4\"&gt; &lt;p class=\"title\"&gt;&lt;a href=\"#item4\"&gt;4&lt;/a&gt;&lt;/p&gt; &lt;p class=\"content ml3\"&gt;4&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374ul,li,p &#123; margin: 0; padding: 0; list-style: none;&#125;.container &#123; width: 400px; height: 300px; background-color: silver; border: 1px solid silver;&#125;.container ul &#123; width: 100%; height: 100%; overflow: hidden;&#125;.container .item &#123; float: left; width: 25%; height: 100%; background-color: white;&#125;.container .item .title &#123; line-height: 40px; border: 1px solid silver; box-sizing: border-box; text-align: center; cursor: pointer;&#125;.container .item a &#123; display:inline-block; width:100%; height:100%; text-decoration: none;&#125;.container .item .content &#123; width: 400%; height: 100%; background-color: yellow;&#125;.ml1 &#123; margin-left: -100%;&#125;.ml2 &#123; margin-left: -200%;&#125;.ml3 &#123; margin-left: -300%;&#125;.active &#123; position: relative; z-index: 1&#125;.container .item:target &#123; position: relative; z-index: 1&#125;.container .item:target .title &#123; border-bottom: none; background-color: yellow;&#125;2、hover实现（1）针对布局一：无法简单的通过CSS实现（2）针对布局二：1234567891011121314151617181920&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"item active\"&gt; &lt;p class=\"title\"&gt;1&lt;/p&gt; &lt;p class=\"content\"&gt;1&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;2&lt;/p&gt; &lt;p class=\"content ml1\"&gt;2&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;3&lt;/p&gt; &lt;p class=\"content ml2\"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;p class=\"title\"&gt;4&lt;/p&gt; &lt;p class=\"content ml3\"&gt;4&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ul,li,p&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver; border:1px solid silver;&#125;.container ul&#123; width:100%; height:100%; overflow:hidden;&#125;.container .item&#123; float:left; width:25%; height:100%; background-color:white;&#125;.container .item .title&#123; line-height:40px; border:1px solid silver; box-sizing:border-box; text-align:center; cursor:pointer;&#125;.container .item .content&#123; width:400%; height:100%; background-color:yellow;&#125;.ml1&#123; margin-left:-100%;&#125;.ml2&#123; margin-left:-200%;&#125;.ml3&#123; margin-left:-300%;&#125;.active&#123; position:relative; z-index:1&#125;.container .item:hover&#123; position:relative; z-index:1&#125;.container .item:hover .title&#123; border-bottom:none; background-color:yellow;&#125;3、label与:checked实现（1）针对布局一：1234567891011121314151617181920&lt;div class=\"container\"&gt; &lt;div class=\"tab-content\"&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item1\" checked/&gt; &lt;div class=\"item\"&gt;内容1&lt;/div&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item2\" /&gt; &lt;div class=\"item\"&gt;内容2&lt;/div&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item3\" /&gt; &lt;div class=\"item\"&gt;内容3&lt;/div&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item4\" /&gt; &lt;div class=\"item\"&gt;内容4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"tab-control\"&gt; &lt;ul&gt; &lt;li&gt;&lt;label for=\"item1\"&gt;内容1&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label for=\"item2\"&gt;内容2&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label for=\"item3\"&gt;内容3&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label for=\"item4\"&gt;内容4&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ul,li &#123; margin: 0; padding: 0; list-style: none;&#125;.container &#123; width: 400px; height: 300px; background-color: silver;&#125;.tab-content &#123; position: relative; width: 100%; height: 80%; overflow: hidden;&#125;input &#123; margin: 0; width: 0;&#125;.tab-content .item &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%;&#125;.tab-control &#123; width: 100%; height: 20%;&#125;.tab-control ul &#123; height: 100%;&#125;.tab-control li &#123; width: 25%; height: 100%; float: left; border: 1px solid silver; box-sizing: border-box; background-color: white;&#125;.tab-control li:hover &#123; background-color: #7b7474&#125;.tab-control label &#123; display: inline-block; width: 100%; height: 100%; line-height: 100%; text-align: center; text-decoration: none; cursor: pointer;&#125;.tab-control label::after &#123; content: \"\"; display: inline-block; height: 100%; vertical-align: middle;&#125;.tab-content .radio-item&#123; display:none;&#125;.tab-content .radio-item:checked+.item &#123; z-index: 1; background-color: yellow;&#125;利用css :checked与+（选择紧接在另一个元素后的元素，而且二者有相同的父元素）选择符。（2）针对布局二：123456789101112131415161718192021222324&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"item active\"&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item1\" checked/&gt; &lt;label class=\"title\" for=\"item1\"&gt;1&lt;/label&gt; &lt;p class=\"content\"&gt;1&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item2\" /&gt; &lt;label class=\"title\" for=\"item2\"&gt;2&lt;/label&gt; &lt;p class=\"content ml1\"&gt;2&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item3\" /&gt; &lt;label class=\"title\" for=\"item3\"&gt;3&lt;/label&gt; &lt;p class=\"content ml2\"&gt;3&lt;/p&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;input type=\"radio\" name=\"item\" class=\"radio-item\" id=\"item4\" /&gt; &lt;label class=\"title\" for=\"item4\"&gt;4&lt;/label&gt; &lt;p class=\"content ml3\"&gt;4&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657ul,li,p&#123; margin:0; padding:0; list-style:none;&#125;.container&#123; width:400px; height:300px; background-color:silver; border:1px solid silver;&#125;.container ul&#123; width:100%; height:100%; overflow:hidden;&#125;.container .item&#123; float:left; width:25%; height:100%; background-color:white;&#125;.container .item .title&#123; display:inline-block; width:100%; line-height:40px; border:1px solid silver; box-sizing:border-box; text-align:center; cursor:pointer;&#125;.container .item .content&#123; position:relative; width:400%; height:100%; background-color:yellow;&#125;.ml1&#123; margin-left:-100%;&#125;.ml2&#123; margin-left:-200%;&#125;.ml3&#123; margin-left:-300%;&#125;.radio-item&#123; display:none;&#125;.radio-item:checked~.title&#123; background-color:yellow; border-bottom:none;&#125;.radio-item:checked~.content&#123; background-color:yellow; z-index:1;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"Tab布局","slug":"Tab布局","permalink":"https://jaycewu.site/tags/Tab布局/"}]},{"title":"CSS中line-height与vertical-align","slug":"CSS中line-height与vertical-align","date":"2017-03-28T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/03/28/CSS中line-height与vertical-align/","link":"","permalink":"https://jaycewu.site/2017/03/28/CSS中line-height与vertical-align/","excerpt":"","text":"参考文章：深入了解CSS的line-height属性Vertical-Align: 你需要知道的所有事【译】Vertical-Align: All You Need To Know1、什么是行间距或者行高（line-height）line-height是指文本行基线间的垂直距离。1.1、顶线，中线，基线，底线从上到下分别是顶线，中线，基线，底线。vertical-align的四个属性top,middle,baseline,bottom就是与这四条线有关。1.2、行高，行距，半行距行高是指上下文本行基线间的垂直距离。（上图中两条红线间的垂直距离）行距是指一行底线到下一行顶线的垂直距离。（第一条粉线和第二条绿线间的垂直距离）半行距就是行距/2。(图中可以看出，半行距=(行高-字体size)/2 )1.3、内容区，行内框，行框内容区：顶线和底线包裹的区域（字体的size）行内框：在没有其他因素影响的时候（padding等），行内框等于内容区。而设定行高时行内框高度不变，半行距分别增加/减少到内容区的上下两边（深蓝色区域）行框（line box）。（字体size不变，修改行高就是修改行距）行框：行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度），当有多行内容时，每行都会有自己的行框。1.4、line-height的设置百分比方式设置1234&lt;body&gt; 121212 &lt;p&gt;121212&lt;/p&gt;&lt;/body&gt;1234567body&#123; font-size:16px; line-height:120%;&#125;p&#123; font-size:32px;&#125;line-height的百分比（120%）和body的字体大小（16px），被用来计算（16*120=19.2），这个值会被层叠下去的元素所继承。补充12345p&#123; font-size:32px; line-height:60px; padding:10px&#125;最终盒模型盒模型中，内容（不是上文说的内容区，上文的内容区是顶线与底线间的区域）的高度等于line-height的值。为什么会有margin？浏览器默认P的上下margin是1em,设置了P的font-size是32px,所以1em=32px。上下margin就是32px。长度方式（px）设置1234&lt;body&gt; 121212 &lt;p&gt;121212&lt;/p&gt;&lt;/body&gt;1234567body&#123; font-size:16px; line-height:20px;&#125;p&#123; font-size:32px;&#125;值normal1234&lt;body&gt; 121212 &lt;p&gt;121212&lt;/p&gt;&lt;/body&gt;1234567body&#123; font-size:16px; line-height:normal;&#125;p&#123; font-size:32px;&#125;bodybody的line的line-height是22px,所以normal等于1.375p的line-height：32px*1.375=44px（normal并不是精确的等于1.375）纯数字就是将normal改为一个想要的准确数字。1.5、各种BOX123&lt;body&gt; &lt;p&gt;这个&lt;em&gt;强调&lt;/em&gt; 元素为行内元素&lt;/p&gt;&lt;/body&gt;12345678body&#123; font-size:16px; line-height:1.5;&#125;p&#123; font-size:32px; padding:10px;&#125;containing boxp就是一个containing box，包含了其他boxs。inline box在段落内，有一系列的inline box,inline box不会让内容成块显示，而是排成一行。“强调”是一种inline box,“这个”，“元素为行内元素”为一种匿名inline box。line box多个inline box组成line box，多个line box组成containing box。Content AreaContent Area是围绕着文字的一种看不见的box,高度取决与font-sizeinline box与line-heightfont-size:32px，line-height:48px，行间距=48px-32px=16px，半行间距=8px。半行间距会用在Content Area的顶部和底部。这里inline box的高度就是line-height。inline box包着Content Area但是，当line-height小于font-size。line box的高度还是line-height,所以line-box的高度小于Content Area的高度，Content Area会溢出line-box。inline box 与line boxline box的高度取决于他内部最高的inline box。2、vertical-alignvertical-align是用来对齐内联级元素的。设置为以下display属性的元素，它们都被认为属于内联级元素。inline、inline-block or inline-table (本文中不涉及此种情况)：inline内联元素基本上是包裹文本的标签。inline-block内联块元素则如它们的名字所示：拥有内联特性的块元素。他们可以有width和height（可能是由自己的内容定义），以及padding、border和margin。内联级元素彼此紧挨着放在一行中。一旦有更多的元素被放置到当前行中，一个新的行将会在它下面创建。所有这些行有所谓的“行框”，行框中包含所有的内容。不同大小的内容意味着不同高度的行框。在下面的插图中，行框的顶部和底部都是用红线表示的。在行框中，元素的vertical-align属性是负责垂直对齐的。那么，到底元素垂直对齐的参照物是什么？参照物：父元素的基线和外边缘看看元素的基线和行框的外观：inline元素：三行并排的文本。行框的顶部和底部边缘用红线表示，字体的高度由绿线表示，基线由一条蓝线表示。在左边，有一个line-height设置为与字体font-size大小相同高度的文本，绿线和红线重叠在一条线上。在中间，line-height是字体的两倍大。在右边，line-height是字体大小的一半大。内联元素（display:inline）的外边缘与其行高的顶部和底部边缘对齐，行高可以小于字体的高度。所以，行框就是上面的图中的红线。内联元素的基线是字符放置的位置线（字母x底部所在的水平线），即图中的蓝线。粗略地说，基线是在字体1/2高度的下面的某个地方。inline-block元素：inline-block因为已经有宽和高，可能存在多行，每行都有自己的基线和行框，所以会比较特殊。上图中，最外层是div，里面分别是三个inline-block的span，黄色为border，绿色为padding，蓝色为content area（一个span，其中有一个字母“C”）。左边的inline-block的span的内容（span）是一个正常文档流元素。中间的inline-block的span还额外加了overflow: hidden。右边的inline-block的span包含一个流外的span(但内容区域有一个高度)(译者注：流内的元素必须是普通文档流（normal flow）中的元素，流外的元素必须是浮动或绝对定位的元素以及根元素。)。蓝线为每个inline-block的span的基线。内联块元素的外边缘是其margin框的顶部和底部边缘，即图中的红线。内联块元素（上图三个inline-block的span）的基线取决它包含的内容是否在文档流中：在流内内容的情况下，内联块元素的基线是正常流中最后一个内容元素的基线（左边的例子）。对于这最后一个元素，它的基线是根据它自己的规则找到的。123456&lt;div class=\"demo1\"&gt; x&lt;span&gt; x&lt;span style=\"display:inline-block;height:30px;width:100px;background-color:blue\"&gt;x&lt;/span&gt; x &lt;/span&gt;&lt;/div&gt;123456.demo1 span&#123; display:inline-block; background-color:silver; height:90px;&#125;灰色背景的元素内部有三个子元素，两个“x”,一个span。元素的基线就是最后一个正常流元素（“x”）的基线。修改元素的长度，使其内容出现多行：最外面的X怎么也跟着移动了？这涉及行框基线的移动，下文细说。在流内内容但内联块元素有overflow:hidden属性的情况下，基线是内联块元素margin框的底部边缘（例如在中间的图）。修改上面的例子样式：12345678.demo1&gt;span&#123; display:inline-block; background-color:silver; height:90px; width:100px; margin:10px; overflow:hidden;&#125;通过最外面的x大致知道行框的基线位置，就是内联块元素的下外边距的地方，也是内联块元素元素的基线位置。一开始此处有疑惑：内联块元素元素的基线跑到了下外边距处，那么元素里面的内容不应该以这条基线做定位吗？群里问了大佬，内联块元素已经设了宽高，可能有多行（即使只有一行），每行有各自的行框，然后又根据规则定位了，跟内联块元素的基线已经没有关系。在流外内容的情况下，基线是内联块元素margin框的底部边缘（例如在右边）。12345&lt;div class=\"demo1\"&gt; x&lt;span&gt; &lt;span style=\"display:inline-block;height:30px;width:100px;background-color:blue;\"&gt;x&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;123456.demo1&gt;span&#123; display:inline-block; background-color:silver; height:90px; width:100px;&#125;加上浮动12345&lt;div class=\"demo1\"&gt; x&lt;span&gt; &lt;span style=\"display:inline-block;height:30px;width:100px;background-color:blue;float:left\"&gt;x&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;行框的基线是可变的当使用vertical-align时，基线放置在哪里可能是最令人疑惑的部分。它需要满足vertical-align的值和行框的高度等所有条件。基线的位置犹如是方程中的一个自由参数。行框的基线是看不见的，但你可以使它很容易看到。只要在文本行的开头添加一个字符，像我增加了一个“X”的字母。如果这个字符不以任何方式对齐，它将默认地坐在基线上。围绕着行框的基线的部分（绿线），我们可以称其为文本框。文本框可以简单地被认为是行框内的内联元素，没有任何对齐。文本框的高度等于它的父元素的字体大小。因此，文本框只围住了行框内的无格式文本。由于这个文本框是绑在基线上的，当基线移动时它将移动。（注：此文本框在W3C规范中称为“strut（支柱）”）vertical-align的值1）将元素的基线，参照父元素的基线对齐baseline：元素的基线与父元素的基线对齐。sub：元素的基线偏移到父元素的基线之下。sup：元素的基线偏移到父元素的基线之上。：元素的基线相对于父元素的基线偏移了一个百分比（该百分比是对比元素自身的line-height计算得出）。：元素的基线相对于父元素的基线偏移了一个绝对长度。2）将元素的中心点，参照父元素的基线对齐middle：将元素的顶部和底部之间的中心点，对齐父元素的基线之上x-height的1/2之处（x-height为字母x的字符高度）。3）将元素的外边缘，参照父元素的文本框对齐text-top：将元素的顶部边缘，对齐到父元素的文本框的顶部边缘。text-bottom：将元素的底部边缘，对齐到父元素的文本框的底部边缘。4）将元素的外边缘，参照父元素行框的外边缘对齐top：元素的顶部边缘对齐到父元素的顶部边缘。bottom：元素的底部边缘对齐到父元素的底部边缘。基线的移动如果一行中有一个高个的元素占据了整行的高度，那么vertical-align对它没有影响。它的顶部和底部没有空间让它移动。为了满足行框基线的对齐方式，行框的基线必须移动。矮个元素设置了vertical-align: baseline。在左边，高个元素设置了vertical-align: text-bottom。在右边，高个元素设置了vertical-align: text-top。你可以看到右边的基线跳起来了。（左）将两个元素放在一行中并设置vertical-align ，它们会使得行框的基线移动到符合它俩的对齐规则之处，然后行框的高度也会随之调整。（中）添加第三个元素，不超越行框的边缘，既不影响行框的高度，也不影响基线的位置。（右）添加第三个元素，如果它超出了行框的边缘，行框的高度和基线调整。在这种情况下，我们的前两个元素也会跟着发生变化。内联级元素底部的小间隙列表项坐在基线上。下面的一点空间，是文本的基线以下预留的depth（在W3C规范中，一个字体的基线以上称为characteristic height，基线以下称为depth）。想要去掉这个depth空隙，有解决的办法吗？只要移动基线的位置就可以，例如通过设置列表项目vertical-align: middle水平垂直居中12345&lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; 自适应垂直居中 &lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728html&#123; height:100%;&#125;body&#123; height: 100%; width: 100%;&#125;.box&#123; display:inline-block; text-align: center; width:50%; height:50%; background-color:#e1e3cd; overflow:hidden;&#125;.box:after&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle;&#125;.content&#123; vertical-align:middle; background-color:silver; display: inline-block; width: 50%; height:50%;&#125;要将content水平垂直居中定位在box里，利用vertical-align是其中一种方法。原理是：vertical-align：middle（将元素的顶部和底部之间的中心点，对齐父元素的基线之上x-height的1/2之处（x-height为字母x的字符高度）。），content肯定是要垂直居中的，那只能修改行框的基线位置（注意：不是修改box的基线，box具有宽高，它里面的内容可能会有多行，每行有各自的行框，box的基线已经不会影响内容的布局，但是box的基线还是会受里面内容的影响（内联块元素的基线是正常流中最后一个内容元素的基线）），使其位于box的垂直中心位置。修改行框的基线，只要在box内加一个高度为100%的空元素，然后设置vertical-align:middle，添加的元素已经占满整个行框高度，而只要移动行框的基线，就可以满足定位规则，所以行框的基线就被移动到box垂直中心位置。content再按规则对齐到行框基线上就可以了。","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"line-height","slug":"line-height","permalink":"https://jaycewu.site/tags/line-height/"},{"name":"vertical-align","slug":"vertical-align","permalink":"https://jaycewu.site/tags/vertical-align/"}]},{"title":"CSS中的BFC，外边距折叠，清除浮动","slug":"CSS中的BFC，外边距折叠，清除浮动","date":"2017-03-16T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/03/16/CSS中的BFC，外边距折叠，清除浮动/","link":"","permalink":"https://jaycewu.site/2017/03/16/CSS中的BFC，外边距折叠，清除浮动/","excerpt":"","text":"BFC是什么？BFC（Block Formatting Context）直译为“块级格式化范围 ”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。BFC 的特征在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。计算BFC的高度时，浮动元素也参与计算（可用于解决浮动造成的高度塌陷问题）BFC的区域不会与float box重叠(解决浮动元素文字环绕问题)触发BFCfloat 的值不为noneposition 的值不为static或者relativedisplay的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个overflow的值不为visible满足上述条件中至少一项，即可触发 BFC使用场景1、外边距折叠问题折叠的条件：两个元素的 margin 必须是 相邻 的；两个 margin 是邻接的必须满足以下条件：必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC 当中。没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开。都属于垂直方向上相邻的外边距。如下：123456&lt;div clss=\"container\"&gt; &lt;div class=\"f-block\"&gt; &lt;/div&gt; &lt;div class=\"s-block\"&gt; &lt;/div&gt;&lt;/div&gt;1234567891011121314.f-block&#123; width:200px; height:200px; background-color:silver; margin:10px;&#125;.s-block&#123; width:200px; height:200px; background-color:silver; margin:10px;&#125;解决方法：破坏产生折叠的条件即可：1、给元素添加浮动或者绝对定位（会影响整体布局，改动大）2、将元素改为行内元素（会影响整体布局，改动大）3、元素间插入一个高度大于0的div4、使元素不在同一BFC中123456&lt;!--元素间插入一个高度大于0的div--&gt;&lt;div class=\"f-block\"&gt;&lt;/div&gt;&lt;div style=\"height:0.01px\"&gt;&lt;/div&gt;&lt;div class=\"s-block\"&gt;&lt;/div&gt;元素间插入一个高度大于0的div1234&lt;div class=\"f-block\"&gt;&lt;/div&gt;&lt;div&gt; &lt;div class=\"s-block\"&gt;&lt;/div&gt;&lt;/div&gt;f-block,s-block以及s-block外层div已经还是处在相同BFC中，所以还是会产生外边距折叠。这里产生的折叠比较复杂：首先是s-block和外层div的外边距折叠，然后是合并后的折叠外边距再与f-block产生外边距折叠。下面解决父子元素的外边距折叠问题：给父元素添加padding 或 border（破坏外边距折叠条件）12345678910![](http://upload-images.jianshu.io/upload_images/2125695-d1892c0eba36f877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)**给父元素创建新的块级格式化上下文（创建了新的块级格式化上下文的块元素，不与它的子元素发生margin 折叠）**```xml&lt;div class=&quot;f-block&quot;&gt;&lt;/div&gt;&lt;div style=&quot;background-color:red;overflow:hidden&quot;&gt; &lt;div class=&quot;s-block&quot;&gt;&lt;/div&gt;&lt;/div&gt;2、清除浮动1234567&lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;12345678910111213.container&#123; width:550px; border:5px solid red;&#125;.item&#123; width:100px; height:100px; float:left; background-color:silver; margin:5px;&#125;对于上面的代码，我们希望得到这样的结果：但结果却是这样的：原因是因为浮动元素脱离文档流，container的高度无法被撑开。清除浮动的方法及原理：clear属性：clear属性的意义就是禁止特定方向上存在浮动元素，例如clear: left就是不允许元素左方存在文档流之前浮动元素（注意，这里左边如果存在文档流之后的浮动元素是无法清理的）根据CSS权威指南，具体的实现原理是通过引入清除区域，这个相当于加了一块看不见的框把定义clear属性的元素向下挤，直到元素指定方向刚好没有浮动元素，这样看起来包含框就把浮动框给包含了，实际上浮动框脱离文本流的性质没变，它们依然是“浮”在上面的用法：1、容器内结尾处加空div标签 clear:both2、容器定义伪类:after 和 zoom(IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题)12.container:after&#123;display:block;clear:both;content:\"\";visibility:hidden;height:0&#125;.container&#123;zoom:1&#125;容器形成新BFC：计算BFC的高度时，浮动元素也参与计算123456.container&#123; width:550px; border:5px solid red; overfow:hidden;&#125;或者使容器自身浮动也可以消除浮动引起的文字环绕效果：1234&lt;div class=\"box\"&gt; &lt;div class=\"img\"&gt;image&lt;/div&gt; &lt;div class=\"info\"&gt;信息信息信息信息信息信息信息信息信息信息信息信信息信息信息信息信息信息信息信息信息信息信息信信息信息信息信息信息信息信息信息信息信息信息信信息信息信息信息信息信息信息信息信息信息信息信&lt;/div&gt;&lt;/div&gt;123.box &#123;width:210px;border: 1px solid #000;float: left;&#125; .img &#123;width: 100px;height: 100px;background: #696;float: left;&#125; .info &#123;background: #ccc;color: #fff;&#125;带有浮动属性的元素会脱离标准流进行排列布局，脱离标准流后的元素就不和块元素相处在同一个流不居中，使得带有浮动属性的元素漂浮在正常块元素上面。但是浮动的块虽然脱离了正常的文档流，但是依然占据正常文档流的文本空间。于是在其后面写的文本并不会被浮动元素所覆盖而是继续水平排列超出换行。标准流中块元素每个各占一行。内联元素则是水平排列，直到一行排列不下进行换行操作。因为使用了float的元素占据文本空间，使得后面的文本以除了浮动元素之外的空间为排列基准，形成了文本环绕的效果。清除环绕效果就是使info形成一个新的BFC（BFC的区域不会与float box重叠），添加overflow:hidden即可。注意：给info绝对定位也会形成一个新的BFC，但是info会按照绝对定位的规则进行布局，会与img重叠。参考文章深入理解BFC和Margin Collapse细说CSS中的BFC","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"BFC","slug":"BFC","permalink":"https://jaycewu.site/tags/BFC/"},{"name":"外边距折叠","slug":"外边距折叠","permalink":"https://jaycewu.site/tags/外边距折叠/"},{"name":"清除浮动","slug":"清除浮动","permalink":"https://jaycewu.site/tags/清除浮动/"}]},{"title":"一个商品SKU是怎么生成的","slug":"一个商品SKU是怎么生成的","date":"2017-03-04T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2017/03/04/一个商品SKU是怎么生成的/","link":"","permalink":"https://jaycewu.site/2017/03/04/一个商品SKU是怎么生成的/","excerpt":"","text":"首先说一说什么是SKU。。。。。。。自己百度去。。。类似京东上面，未来人类S5这个台笔记本都是S5这个型号，但是因为CPU,显卡，内存，硬盘等不同，价格也不一样。CPU,显卡，内存，硬盘等属性组合成的一个唯一的商品，就可以用一个SKU来表示,像图上就有10个SKU。一系列的SKU可以归到一个SPU下进行管理。那么一个SKU是怎么生成的呢？下面结合自己的一些经验，说说一些电商平台的大致产品结构以及SKU的生成方式。1.阿里速卖通平台,阿里国际站这两个平台同一个爸爸，基本差不多。要创建一个商品需要先选一个类目，类目下面挂了一堆的属性，属性上又挂了一堆的属性值。属性分为销售属性和非销售属性（销售属性就是类似颜色，尺寸这些单个SKU独有的，非销售属性就是多个SKU共有的，比如同一个品牌型号“未来人类S5”）。非销售属性有必填和非必填，可以是单选，多选，文本等。销售属性就是构成SKU的关键。比如说有销售属性颜色和尺寸，颜色属性下有很多属性值（红，黄，蓝等等），尺寸（1,2,3,4等等）也是。当颜色选了红，黄，尺寸选了1,2，那么就应该生成2x2=4个SKU，每个SKU有各自的价格，库存等。保存SKU的时候会与对应的销售属性相关联。大致的数据模型如下当然，实际比这更加复杂（比如产品的图片，单个SKU的图片，多个SKU共同的图片,非销售属性可以自定义添加分类不具有的。。。）2.eBay跟上面两个平台类似，创建一个产品也要先选一个分类，分类下面也是有很多属性，属性有很多属性值。。。，不同的地方是eBay没有区分销售属性和非销售属性（或者说全部是非销售属性），也允许添加自定义属性和属性值。eBay上SKU是手动添加的，SKU上的属性(SKU上的属性暂且都叫做销售属性)也是自定义的。比如说添加了一个SKU A,价格和数量这两个是必须的，还可以手动加个颜色属性，然后填上属性值红色。当然，若果增加一个SKU B，那么这个SKU也会有颜色这个属性，属性值可以自定义。最后校验这些SKU的属性值组合起来是否唯一。这样的优势就是可以随意控制SKU的数量，如果按照上面两个平台的规则，这里应该有4x4x1=16个SKU。这样自由度更高会不会使结构更加复杂呢？当然是NO，用上面的数据模型就可以搞定3.Lazada,Linio平台国际惯例，先选一个类目，类目下面一堆属性，有必填和非必填，属性下一堆属性值。最大的区别就是，一个产品只有一个SKU，属性不支持自定义。比如说要添加一个商品，有两种颜色，那么只能创建两个产品，这两个产品可能只有图片不一样（颜色不一样，可能没有颜色这个属性来选）4.Wish平台比较奇特，没有分类，产品有固定的属性，比如标题，描述，运费等。一个产品下可以有多个SKU，SKU的生成取决于固定的两大类属性，两个大类为：颜色和尺寸。比如颜色这个属性就是归类于颜色这个类，其他的属性（品牌，型号，容量等等归为尺寸这个大类）。尺寸类的属性值支持自定义，但只能选一个尺寸类属性（比如选了品牌就不能选容量，选了品牌后可以添加任意值）。两类属性不是必须同时存在，比如颜色选了红，可以不选尺寸类的属性，反之也一样。忘记说了，一个SKU是靠一串唯一编码来标识的，比如1234A，1234B。一般来说一个平台下不会存在两个相同的SKU，或这一个店铺下不会存在两个相同的SKU。大致的逻辑和数据模型就这些，接下来说说开发实现方面。数据库大致就依靠上面的数据模型进行设计，编辑的时候，后端按照这些关联关系取出数据给到前端（我这边前后端未分离，页面还是后端渲染，但我还是把数据格式化为JSON再渲染到前端），保存的时候再进行相关的逻辑校验。因为后端的一些逻辑操作涉及后公司内部的业务，这里就不细说了。说说前端的具体细节，以速卖通的为例，用的是vue，前端拿到的数据如下属性数据，(变量properties)sku数据（变量skus）实现后的粗糙界面1234data:&#123; properties: properties, skus: skus &#125;遍历properties，得到材质，颜色，发货地，套餐这些属性对象，接着遍历这些对象里的values属性,得到属性值对象,根据属性对象的selectedValues判断属性值是否选上（因为我是后端渲染的js变量，所以初始化的时候selectedValues里的数据直接引用的属性值对象，如果是非后端渲染的话，要根据skus里的属性和属性值去初始化selectedValues的数据，并且存的是属性值对象的引用）1234567891011121314151617181920212223242526272829303132333435&lt;tr v-for=\"(index,item) in properties\"&gt; &lt;td&gt;&lt;strong&gt;&#123;&#123;item.Name&#125;&#125;：&lt;/strong&gt;&lt;/td&gt; &lt;td&gt; &lt;label v-for=\"value in item.values\"&gt;&lt;input type=\"checkbox\" :value=\"value\" v-model=\"item.selectedValues\"/&gt;&#123;&#123;value.Name&#125;&#125;&lt;/label&gt; &lt;table class=\"list_table\" v-if=\"item.Name!='发货地'&amp;&amp;item.selectedValues.length&gt;0\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&#123;&#123;item.Name&#125;&#125;&lt;/th&gt; &lt;th&gt;自定义名称&lt;/th&gt; &lt;th v-if=\"item.Name=='颜色'\"&gt;图片（无图片可以不填）&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=\"selectedValue in item.selectedValues\"&gt; &lt;td&gt;&#123;&#123;selectedValue.Name&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" v-model=\"selectedValue.DefinitionName\" maxlength=\"20\"/&gt; &lt;/td&gt; &lt;td v-if=\"item.Name=='颜色'\"&gt; &lt;div style=\"float: left\"&gt; &lt;input type=\"file\" style=\"width: 63px;\"/&gt; &lt;/div&gt; &lt;div style=\"float: right\"&gt; &lt;a href=\"\" rel=\"link\" target=\"_blank\"&gt; ![](selectedValue.ImageUrl) &lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt;因为selectedValues通过v-model绑定，当选中或取消一个属性值的时候后，selectedValues也会随着改变，selectedValues里的数据是直接引用属性值而不是拷贝一份数据，所以修改selectedValues中的数据也会直接反映到属性值上，实现了属性值的自定义。那么怎么根据选中的属性值生成SKU呢？SKU表格处的表头是要根据选中的属性动态更新的，可以这样做123456&lt;tr&gt; &lt;th v-for=\"item in properties\" v-if=\"item.selectedValues.length&gt;0\"&gt;&#123;&#123;item.Name&#125;&#125;&lt;/th&gt; &lt;th&gt;&lt;span class=\"c_red\"&gt;*&lt;/span&gt;零售价&lt;/th&gt; &lt;th&gt;&lt;span class=\"c_red\"&gt;*&lt;/span&gt;库存&lt;/th&gt; &lt;th&gt;商品编码&lt;/th&gt; &lt;/tr&gt;如果属性里的属性值都没有被选中（selectedValues.length==0），就不在表头显示这个属性。SKU的初始显示123456&lt;tr v-for=\"sku in skus\"&gt; &lt;td v-for=\"item in properties\" v-if=\"item.selectedValues.length&gt;0\"&gt;&#123;&#123;getValueName(sku,item)&#125;&#125;&lt;/td&gt; &lt;td&gt;US $&lt;input type=\"text\" v-model=\"sku.SkuPrice\" class=\"w50\" maxlength=\"9\"/&gt;&lt;span name=\"productUnitTips\"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" v-model=\"sku.StockQuantity\" class=\"w50\" maxlength=\"9\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" v-model=\"sku.SkuCode\" class=\"w180\" maxlength=\"20\"/&gt;&lt;/td&gt;&lt;/tr&gt;也是利用selectedValues.length让SKU的属性值列数与表头列数保持一致。因为SKU对象里的保存的是属性值Id和属性Id,需要一个方法去获取属性值的值1234567891011121314151617getValueName: function (sku, property) &#123; var valueName = \"\"; $.each(sku.values, function () &#123; var _this = this; if (this.propertyId == property.Id) &#123; $.each(property.selectedValues, function () &#123; if (_this.valueId == this.Id) &#123; valueName = this.Name; return false; &#125; &#125;); &#125; &#125;); return valueName; &#125;你没有看错，这是JQ。。。接下来就是SKU表格的更新了，我的做法是变更整块区域，就是给skus重新赋值。赋的新值从哪来呢？将选中的属性值放到一个数组中12345678var ori = []; $.each(vm.properties, function (index, item) &#123; var selectValues = this.selectedValues; if (selectValues.length &gt; 0) &#123; ori.push(selectValues); &#125; &#125;);得到这种结构的数组12345678910111213141516171819202122232425262728293031323334[ [ &#123; 'PropertyId': 10, 'Id': 477, 'Name': '铝', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 10, 'Id': 529, 'Name': '帆布', 'DefinitionName': '', 'ImageUrl': '' &#125; ], [ &#123; 'PropertyId': 200000828, 'Id': 201655809, 'Name': '壳＋贴膜', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 200000828, 'Id': 201655810, 'Name': '壳＋挂绳', 'DefinitionName': '', 'ImageUrl': '' &#125; ]]求笛卡尔积后（后面有求笛卡尔积参考链接）1var ret = descartes(ori);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[ [ &#123; 'PropertyId': 10, 'Id': 477, 'Name': '铝', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 200000828, 'Id': 201655809, 'Name': '壳＋贴膜', 'DefinitionName': '', 'ImageUrl': '' &#125; ], [ &#123; 'PropertyId': 10, 'Id': 477, 'Name': '铝', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 200000828, 'Id': 201655810, 'Name': '壳＋挂绳', 'DefinitionName': '', 'ImageUrl': '' &#125; ], [ &#123; 'PropertyId': 10, 'Id': 529, 'Name': '帆布', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 200000828, 'Id': 201655809, 'Name': '壳＋贴膜', 'DefinitionName': '', 'ImageUrl': '' &#125; ], [ &#123; 'PropertyId': 10, 'Id': 529, 'Name': '帆布', 'DefinitionName': '', 'ImageUrl': '' &#125;, &#123; 'PropertyId': 200000828, 'Id': 201655810, 'Name': '壳＋挂绳', 'DefinitionName': '', 'ImageUrl': '' &#125; ]]大前端也用上了算法有木有，这里需要弄明白拿到的是什么数据，需要的是什么数据，然后就去想实现就OK了。想要的数据已经拿到，重新构建skus123456789for (var i = 0; i &lt; ret.length; i++) &#123; var sku = &#123;SkuCode: \"\", SkuPrice: \"\", StockQuantity: \"\"&#125;; sku.values = []; $.each(ret[i], function () &#123; sku.values.push(&#123;propertyId: this.PropertyId, valueId: this.Id&#125;); &#125;); vmSkus.push(sku); &#125;到此，更新SKU表格的代码已经实现，数据驱动视图更新，很清晰。但是什么时候去触发这个更新呢（何时去重新构建skus）? 很简单嘛，就是勾选或取消勾选属性值的时候去触发更新操作。勾选或取消勾选我们能直接从selectedValues.length上得到反馈，然后使用vue 的watch就可以实现了。但是selectedValues是properties数组中元素的一个属性，vue的watch是无法用在数组元素的某一个字段上的（至少目前我发现是这样的），那么暴力一点，直接watch整个properties数组并且加上deep:true。这样是可以实现，但是当修改自定义属性的时候也会触发变更（业务会提刀来见的）。最终解决方案123456789computed:&#123; allCheckedLength:function()&#123; var length=0; $.each(this.properties,function()&#123; length+=this.selectedValues.length; &#125;); return length; &#125; &#125;12345watch: &#123; 'allCheckedLength': &#123; handler: 'reBuild' &#125; &#125;reBuild就是重新构建的方法。demoJava 笛卡尔积算法的简单实现Cartesian product of multiple arrays in JavaScript","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"sku","slug":"sku","permalink":"https://jaycewu.site/tags/sku/"}]},{"title":"webpack resolve.alias ProvidePlugin externals","slug":"webpack resolve.alias ProvidePlugin externals","date":"2016-12-27T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2016/12/27/webpack resolve.alias ProvidePlugin externals/","link":"","permalink":"https://jaycewu.site/2016/12/27/webpack resolve.alias ProvidePlugin externals/","excerpt":"","text":"resolve.alias这个配置项相当于为文件目录配置一个别名比如下面这样的目录结构要在main.js中使用jquery,需要这样var $=require(&quot;./lib/jquery&quot;)。如果lib中的库很多，而且目录也很多，使用的时候就要写一长串的地址。使用resolve.alias配置如下1234567891011121314151617181920module.exports = &#123; entry: &#123; main:'./main.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js' &#125;, resolve:&#123; //配置别名，在项目中可缩减引用路径 alias: &#123; jquery: \"./lib/jquery\" &#125; &#125;, plugins: [ ]&#125;;使用的时候，这样就可以var $=require(&quot;jquery&quot;);配置项中，key值得配置方式也有很多种，更多的可以看这里resolve.alias使我们不用频繁地写一长串的引用路径，但是使用的时候还是先要require，如果我们懒到require都不想写呢？ProvidePlugin这个插件就派上用场了。webpack.config.js1234567891011121314151617181920212223var webpack=require(\"webpack\");module.exports = &#123; entry: &#123; main:'./main.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js' &#125;, resolve:&#123; //配置别名，在项目中可缩减引用路径 alias: &#123; jquery: \"./lib/jquery\" &#125; &#125;, plugins: [ //提供全局的变量，在模块中使用无需用require引入 new webpack.ProvidePlugin(&#123; $: \"jquery\" &#125;), ]&#125;;因为已经配置的别名，所以1new webpack.ProvidePlugin(&#123; $: \"jquery\" &#125;)就可以，jquery就是我们配置的别名，如果没有配置别名，则要这样写1new webpack.ProvidePlugin(&#123; $: \"./lib/jquery\" &#125;)使用的时候1234var arr=[1,2,3,4];$.each(arr,function()&#123; console.log(this);&#125;);没毛病，但是如果没有配置ProvidePlugin，也没有require,这样写webpack打包的时候是不会报错的，浏览器运行的时候才知道错误。不管是使用resolve.alias还是ProvidePlugin，打包的时候，webpack都会将使用到的库进行打包。打包的方式可以使用CommonsChunkPlugin这个插件再进行配置（我以前的文章中有写这个插件的详细用法）。如果我们不想webpack打包某个文件，而是直接在页面使用script标签手动引入，或者使用CDN资源的时候，externals这个配置项就起作用了。webpack.config.js123456789101112131415module.exports = &#123; entry: &#123; main:'./main.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js' &#125;, externals: &#123; $: \"window.jQuery\" &#125;, plugins: [ ]&#125;;使用12345var $ = require(\"$\");var arr=[1,2,3,4];$.each(arr,function()&#123; console.log(this);&#125;);一定要记得require,不然和不配置externals没区别，不想写可以使用ProvidePlugin1234567externals: &#123; $: \"window.jQuery\" &#125;, plugins: [ //提供全局的变量，在模块中使用无需用require引入 new webpack.ProvidePlugin(&#123; $: \"$\" &#125;) ]打包后然后页面上通过script标签手动引入CDN地址或者本地文件地址就行了，需要注意的是引入的顺序和依赖关系，将webpack打包的文件放到后面引入。其实不使用externals也是可以的，我们看一下不使用externals，直接这样写1234var arr=[1,2,3,4];$.each(arr,function()&#123; console.log(this);&#125;);打包后当我们手动引入JQ后，$肯定是有的，没毛病。但始终感觉这样会给自己挖坑。","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://jaycewu.site/tags/webpack/"}]},{"title":"聊聊浏览器的渲染机制","slug":"聊聊浏览器的渲染机制","date":"2016-12-17T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2016/12/17/聊聊浏览器的渲染机制/","link":"","permalink":"https://jaycewu.site/2016/12/17/聊聊浏览器的渲染机制/","excerpt":"","text":"本文中浏览器特指Chrome浏览器开始之前说说几个概念，以及在准备写这篇文章之前对浏览器的渲染机制的了解：DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构Render Tree：DOM 和 CSSOM 合并后生成 Render Tree(Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点，display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。)查阅了一些关于浏览器渲染机制的文章后，得到以下比较重要或者有争议性的观点：1.Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区。2.Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM3.Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。4.Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。5.Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。出处浏览器的主要组件为 (1.1)：1.用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。2.浏览器引擎 - 在用户界面和呈现引擎之间传送指令。3.呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。4.网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。5.用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。6.JavaScript 解释器。用于解析和执行 JavaScript 代码。7.数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。主流程呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。然后进行如下所示的基本流程：呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。解析算法HTML 无法用常规的自上而下或自下而上的解析器进行解析。原因在于：1.语言的宽容本质。2.浏览器历来对一些常见的无效 HTML 用法采取包容态度。3.解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML处理脚本和样式表的顺序脚本网络的模型是同步的。网页作者希望解析器遇到&lt;script&gt;标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。预解析WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。样式表另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。呈现树构建在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。出处根据以上长篇大论，可以归结为以下几点：文章一：1.浏览器请求到html结构后，并发请求js,css,图片等资源，并不是解析到相应节点才去发送网络请求。文章二：1.HTML解析为dom树，不是简单的自上而下，而是需要不断地反复，比如解析到脚本标签，脚本修改之前已经解析的dom，这就要往回重新解析一遍2.HTML 解析一部分就显示一部分（不管样式表是否已经下载完成）3.&lt;script&gt;标记会阻塞文档的解析(DOM树的构建)直到脚本执行完，如果脚本是外部的，需等到脚本下载并执行完成才继续往下解析。4.外部资源是解析过程中预解析加载的(脚本阻塞了解析，其他线程会解析文档的其余部分，找出并加载)，而不是一开始就一起请求的(实际上看起来也是并发请求的，因为请求不相互依赖)为了直观的观察浏览器加载和渲染的细节，本地用nodejs搭建一个简单的HTTP Server。server.js:1234567891011121314151617181920212223242526272829303132333435const http = require('http');const fs = require('fs');const hostname = '127.0.0.1';const port = 8080;http.createServer((req, res) =&gt; &#123; if (req.url == '/a.js') &#123; fs.readFile('a.js', 'utf-8', function (err, data) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); setTimeout(function () &#123; res.write(data); res.end() &#125;, 10000) &#125;) &#125; else if (req.url == '/b.js') &#123; fs.readFile('b.js', 'utf-8', function (err, data) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.write(data); res.end() &#125;) &#125; else if (req.url == '/style.css') &#123; fs.readFile('style.css', 'utf-8', function (err, data) &#123; res.writeHead(200, &#123;'Content-Type': 'text/css'&#125;); res.write(data); res.end() &#125;) &#125; else if (req.url == '/index.html') &#123; fs.readFile('index.html', 'utf-8', function (err, data) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); res.write(data); res.end() &#125;) &#125;&#125;).listen(port, hostname, () =&gt; &#123; console.log('Server running at ' + hostname);&#125;);index.html:1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;可以看到，服务端将对a.js的请求延迟10秒返回。Server启动后，在chrome浏览器中打开http://127.0.0.1:8080/index.html外部资源是如何请求的看一下TimeLine可以看到，第一次解析html的时候，外部资源好像是一起请求的，最后一次Finish Loading是a.js的，因为服务端延迟的10秒钟。文章二中说资源是预解析加载的，就是说style.css和b.js是a.js造成阻塞的时候才发起的请求，图中也是可以解释得通，因为第一次Parse HTML的时候就遇到阻塞，然后预解析就去发起请求，所以看起来是一起请求的。将index.html内容增加足够多，并且在最后面才加入script:1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;重复&lt;/p&gt;&lt;p&gt;重复&lt;/p&gt;........重复5000行&lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;多刷新几次，查看TimeLine可以发现，当html内容太多的时候，浏览器需要分段接收，解析的时候也要分段解析。还可以看到，请求资源的时机是无法确定的，但肯定不是同时请求的，也不是解析到指定标签的时候才去请求，浏览器会自行判断，如果当前操作比较耗时，就会去加载后面的资源。HTML 是否解析一部分就显示一部分修改 index.html：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;因为a.js的延迟，解析到a.js所在的script标签的时候，a.js还没有下载完成，阻塞并停止解析，之前解析的已经绘制显示出来了。当a.js下载完成并执行完之后继续后面的解析。当然，浏览器不是解析一个标签就绘制显示一次，当遇到阻塞或者比较耗时的操作的时候才会先绘制一部分解析好的。script标签的位置对HTML解析有什么影响修改index.html：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt; &lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt; &lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;还是因为a.js的阻塞使得解析停止，a.js下载完成之前，页面无法显示任何东西。整个处理过程中，Parse HTML 3次，计算元素样式1次，页面布局计算1次，绘制一次。修改index.html：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;解析到a.js部分的时候，页面要显示的东西已经解析完了，a.js不会影响页面的呈现速度。整个处理过程中，Parse HTML 3次，计算元素样式2次，页面布局计算1次，绘制一次。修改index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/b.js'&gt;&lt;/script&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;阻塞后面的解析，导致不能很快的显示。整个处理过程中，Parse HTML 3次，计算元素样式2次，页面布局计算2次，绘制2次。可以发现浏览器优化得非常好，当阻塞在a.js的时候，现将已经解析的部分显示（计算元素样式，布局排版，绘制），当a.js下载好后接着解析和显示后面的（因为a.js后面还有要显示到页面上的元素，所以还需要进行1次计算元素样式，布局排版，绘制）修改index.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;script&gt; document.getElementById(\"hh\").style.height=\"200px\";&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;a.js阻塞的时候，排版，绘制1次；a.js下载完后重排，重绘一次；修改DOM,引起重排，重绘一次。是不是这样呢？看下图事实是修改DOM并没有引起重排，重绘。因为浏览器将a.js下载完成并执行后的一次重排和重绘与修改DOM本应该导致的重排和重绘积攒一批，然后做一次重排，重绘浏览器是聪明的，它不会你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。css文件的影响服务端将style.css的相应也设置延迟。修改index.html：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;可以看出来，css文件不会阻塞HTML解析，但是会阻塞渲染，导致css文件未下载完成之前已经解析好html也无法先显示出来。接着修改index.html：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\"&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;同样阻塞渲染修改index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\" media=\"print\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;&lt;p&gt;3333333&lt;/p&gt;&lt;script src='http://127.0.0.1:8080/a.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;注意media=”print”因为指定了media=”print”，样式不起作用，不会阻塞渲染。&lt;link href=”portrait.css” rel=”stylesheet media=”orientation:portrait”&gt;第一条声明阻塞渲染，匹配所有情况。第二条声明一样阻塞渲染：”all” 是默认类型，如果你未指定任何类型，则默认为 “all”。因此，第一条声明和第二条声明实际上是一样的。第三条声明有一条动态媒体查询，在页面加载时判断。根据页面加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞。最后一条声明只适用打印，因此，页面在浏览器中首次加载时，不会阻塞渲染。但是。。。看一下火狐的表现图片资源的影响修改index.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache,no-store, must-revalidate\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;浏览器渲染&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://127.0.0.1:8080/style.css\" media=\"print\"&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hh'&gt;1111111&lt;/p&gt;&lt;p&gt;222222&lt;/p&gt;[站外图片上传中……(2)]&lt;p&gt;3333333&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;图片比较大，2M多，但服务端还是要延迟10秒响应。图片既不阻塞解析，也不阻塞渲染。图片未请求回来之前，先进行一次layout和paint，paint的范围就是页面初始的可视区域。当返回一部分图片信息后（估计是得到了图片的尺寸），再进行一次layout和paint,paint的范围受到图片尺寸的影响。当图片信息全部返回时，最后进行一次paint。如果固定img的宽高，当返回一部分图片信息后，不会再layout，但仍会paint一次。补充：图片用作背景（不是写在CSS文件内）是在Recalculate Style的时候才发起的请求，layout、paint次数和固定宽高的img一样。背景图属性写在CSS文件里，则CSS文件下载并执行Recalculate Style的时候才会请求图片。参考浏览器的渲染原理简介浏览器的工作原理：新式网络浏览器幕后揭秘JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.htmlhttps://developers.google.cn/web/fundamentals/performance/critical-rendering-path/render-blocking-css","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"渲染机制","slug":"渲染机制","permalink":"https://jaycewu.site/tags/渲染机制/"}]},{"title":"npm小结","slug":"npm小结","date":"2016-11-22T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2016/11/22/npm小结/","link":"","permalink":"https://jaycewu.site/2016/11/22/npm小结/","excerpt":"","text":"修改公共仓库地址windows下，修改C:\\Users\\Administrator下的文件.npmrc，将registry改为淘宝镜像地址，registry=https://registry.npm.taobao.org/。初始化项目根目录下执行命令行npm init，各种参数根据自己需求填写，生成package.json文件。发布自己的npm包在 npm 官网 https://www.npmjs.org 申请一个账号。npm init后，添加要发布的包的相关内容（什么都不加也是可以发布的）。命令行执行npm adduser --registry http://registry.npmjs.org，输入npm官网申请的账户名，密码和邮箱（因为公共npm仓库已经改为淘宝镜像地址，所以--registry http://registry.npmjs.org不能省略）。执行npm publish --registry http://registry.npmjs.org将包发布到npm上。登录到npm官网，点击右上角头像，选中Profile就可以看到发布的包。更新已经发布的包修改相关的内容后，修改包目录下的package.json文件，修改version版本号，比如之前是1.0.0，修改为2.0.0。然后执行npm publish --registry http://registry.npmjs.org就可以将包更新到npm上。npm install全局安装npm install 包名称 -g本地安装,并更新package.json的dependenciesnpm install 包名称 --save。本地安装,并更新package.json的devDependenciesnpm install 包名称 --save-dev。pm update失败比如说之前我们发布到npm上的包名称npm-test,版本为1.0.0，未更新之前npm install npm-test --save-dev安装的就是1.0.0版本的。新发布了一个可用的版本2.0.0后，想更新到最新的版本，运行npm update npm-test,不起作用。原因是因为npm规定了https://docs.npmjs.com/misc/semver#prerelease-identifiers，看不太懂，只知道是这个原因☹dependencies和devDependencies的区别当我们适用别人的包的时候，经常会疑惑，是该npm install xxx --save还是npm install xxx --save-dev。前者是安装包并且更新package.json的dependencies，后者是安装包并更新package.json的devDependencies，如果只是使用别人的包，而不将包发布到npm上，两种方式都可以正常使用。但是当我们要把我们的包发布到npm上时，一定要区分好dependencies和devDependencies的区别。比方说我们之前发布的npm-test包，包中需要使用了vue，那是要执行npm install vue --save还是npm install vue --save-dev呢？当别人使用我们这个包的时候，前提vue这个包已经安装了，但是用户不会去看我们的包依赖哪些包，然后一一得手动去安装这些依赖包。所以当用户 npm insall npm-test --save要使用我们这个包的时候，应该也要自动安装vue这个包。而当我们的包中安装vue的时候，使用npm install vue --save就可以了，用户使用我们的包的时候，也会安装vue这个包。如果我们包的相关的功能代码是用es6写的，并且安装了babel,webpack等相关的包，这些包的安装应该使用npm install vue --save-dev，当用户使用我们的包的时候，不会安装这些包。","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://jaycewu.site/tags/npm/"}]},{"title":"vue-curd","slug":"vue-curd","date":"2016-09-20T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2016/09/20/vue-curd/","link":"","permalink":"https://jaycewu.site/2016/09/20/vue-curd/","excerpt":"","text":"一个简单的vue 增删改查的例子。[在线地址][1]html:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"app\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;查询&lt;/span&gt; &lt;input class=\"form-control\" v-model=\"searchQuery\" type=\"text\" name=\"\" id=\"\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;grid-s :list=\"list\" :colums=\"colums\" :search-Query=\"searchQuery\"&gt;&lt;/grid-s&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"grid-tpl\"&gt; &lt;dialog-s :index=\"index\" :mode=\"mode\" :fields=\"colums\" :title=\"title\" :item=\"item\" @create-item=\"createItem\" @modify-item=\"modifyItem\"&gt;&lt;/dialog-s&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th v-for=\"col in colums\"&gt; &#123;&#123;col.title&#125;&#125; &lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(index,item) in list|filterBy searchQuery\"&gt; &lt;td v-for=\"col in colums\"&gt; &#123;&#123;item[col.title]&#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;button @click=\"openModifyItemDialog(item,index)\" class=\"btn btn-success btn-xs\"&gt;修改&lt;/button&gt; &lt;button @click=\"delItem(index)\" class=\"btn btn-danger btn-xs\"&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=\"container\"&gt; &lt;button class=\"btn btn-success\" @click=\"openNewItemDialog('新增')\"&gt;新增&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"dialog-tpl\"&gt; &lt;div class=\"dialogs\"&gt; &lt;div class=\"dialog\" :class=\"&#123;'dialog-active':show&#125;\"&gt; &lt;div class=\"dialog-content\"&gt; &lt;header class=\"dialog-header\"&gt; &lt;h1 class=\"dialog-title\"&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/header&gt; &lt;div class=\"form-horizontal\"&gt; &lt;div v-for=\"field in fields\" class=\"form-group\"&gt; &lt;label&gt;&#123;&#123;field.title&#125;&#125;&lt;/label&gt; &lt;input class=\"form-control\" v-model=\"item[field.title]\" type=\"text\" name=\"\" id=\"\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"dialog-footer\"&gt; &lt;div class=\"footer-btn\"&gt; &lt;button @click=\"save\" class=\"btn btn-success\"&gt;保存&lt;/button&gt; &lt;button @click=\"close\" class=\"btn btn-danger\"&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"dialog-mask\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677.dialog &#123; width: 350px; position: fixed; left: 50%; top: 2em; transform: translateX(-50%); z-index: 2000; visibility: hidden; backface-visibility: hidden; perspective: 1300px;&#125;.dialog-active &#123; visibility: visible;&#125;.dialog-active .dialog-content &#123; opacity: 1; transform: rotateY(0);&#125;.dialog-active ~ .dialog-mask &#123; opacity: 1; visibility: visible;&#125;.dialog-content &#123; border-radius: 3px; background: #fff; overflow: hidden; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1); transition: .5s ease-in-out; opacity: 0; transform-style: preserve-3d; transform: rotateY(-70deg);&#125;.dialog-header &#123; background: #0090d3; color: #fff;&#125;.dialog-title &#123; margin: 0; font-size: 2em; text-align: center; font-weight: 200; line-height: 2em;&#125;.dialog-body &#123; padding: 2em;&#125;.dialog-footer &#123; margin: 0 2em; padding: 1em 0; border-top: 1px solid rgba(0, 0, 0, 0.1);&#125;.dialog-mask &#123; content: \"\"; position: fixed; visibility: hidden; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; opacity: 0; background: rgba(0, 0, 0, 0.5); transition: all .6s;&#125;.form-horizontal .form-group &#123; margin-right: 15px; margin-left: 15px;&#125;js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Vue.component(\"grid-s\",&#123; template:\"#grid-tpl\", props:[\"list\",\"colums\",\"searchQuery\"], data:function()&#123; return &#123; mode:0, item:&#123;&#125;, title:\"\", index:0 &#125; &#125;, methods:&#123; openNewItemDialog:function(title)&#123; this.title=title; this.mode=1; this.item=&#123;&#125;; this.$broadcast('showDialog', true); &#125;, createItem:function()&#123; this.list.push(this.item); this.$broadcast('showDialog', false); wilddog.set(item); this.item = &#123;&#125;; &#125;, delItem:function(index)&#123; this.list.splice(index,1); &#125;, modifyItem:function()&#123; for (var j in this.item) &#123; this.list[this.index][j] = this.item[j] &#125; this.$broadcast('showDialog', false); this.item = &#123;&#125;; &#125;, openModifyItemDialog:function(item,index)&#123; this.title=\"Edit \"+item.title; this.mode=2; this.item=_.cloneDeep(item); this.index=index; this.$broadcast('showDialog', true); &#125; &#125;, components:&#123; \"dialog-s\":&#123; template:\"#dialog-tpl\", props:[\"mode\",\"title\",\"fields\",\"item\",\"index\"], data:function()&#123; return &#123; show:false &#125; &#125;, methods:&#123; close:function()&#123; this.show=false; &#125;, save:function()&#123; if(this.mode==1)&#123; this.$dispatch('create-item'); &#125; else&#123; this.$dispatch('modify-item'); &#125; &#125; &#125;, events:&#123; 'showDialog': function(show) &#123; this.show = show; &#125; &#125; &#125; &#125;&#125;);var demo=new Vue(&#123; el:\"#app\", data:&#123; searchQuery:'', colums:[&#123;title:\"title\"&#125;,&#123;title:\"sku\"&#125;,&#123;title:\"price\"&#125;], list:[&#123; title:\"sony\", sku:\"23232323A\", price:5000 &#125;,&#123; title:\"Apple\", sku:\"45454545A\", price:6000 &#125;]&#125;&#125;);demo","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://jaycewu.site/tags/vue/"}]},{"title":"简要分析webpack打包后代码","slug":"简要分析webpack打包后代码","date":"2016-09-04T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2016/09/04/简要分析webpack打包后代码/","link":"","permalink":"https://jaycewu.site/2016/09/04/简要分析webpack打包后代码/","excerpt":"","text":"开门见山1.打包单一模块webpack.config.js1234567module.exports = &#123; entry:\"./chunk1.js\", output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;,&#125;;chunk1.js12var chunk1=1;exports.chunk1=chunk1;打包后，main.js(webpack生成的一些注释已经去掉)1234567891011121314151617181920212223242526272829303132333435 (function(modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = \"\"; // Load entry module and return exports return __webpack_require__(0); &#125;)([function(module, exports) &#123; var chunk1=1; exports.chunk1=chunk1;&#125;]);这其实就是一个立即执行函数，简化一下就是：1(function(module)&#123;&#125;)([function()&#123;&#125;,function()&#123;&#125;]);OK,看一下自运行的匿名函数里面干了什么：12345678910111213141516function(modules) &#123; // webpackBootstrap // modules就是一个数组，元素就是一个个函数体，就是我们声明的模块 var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; ... &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = \"\"; // Load entry module and return exports return __webpack_require__(0); &#125;整个函数里就声明了一个变量installedModules 和函数webpack_require，并在函数上添加了一个m,c,p属性，m属性保存的是传入的模块数组，c属性保存的是installedModules变量，P是一个空字符串。最后执行webpack_require函数，参数为零，并将其执行结果返回。下面看一下webpack_require干了什么：123456789101112131415161718function __webpack_require__(moduleId) &#123; //moduleId就是调用是传入的0 // installedModules[0]是undefined,继续往下 if(installedModules[moduleId]) return installedModules[moduleId].exports; // module就是&#123;exports: &#123;&#125;,id: 0,loaded: false&#125; var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // 下面接着分析这个 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 表明模块已经载入 module.loaded = true; // 返回module.exports(注意modules[moduleId].call的时候module.exports会被修改) return module.exports; &#125;接着看一下modules[moduleId].call(module.exports, module, module.exports, webpack_require)，其实就是1modules[moduleId].call(&#123;&#125;, module, module.exports, __webpack_require__)对call不了解当然也可以认为是这样(但是并不是等价，call能确保当模块中使用this的时候，this是指向module.exports的)：12345function a(module, exports) &#123; var chunk1=1; exports.chunk1=chunk1;&#125;a(module, exports,__webpack_require__);传入的module就是{exports: {},id: 0,loaded: false}，exports就是{}，webpack_require就是声明的webpack_require函数(传入这个函数有什么用呢，第二节将会介绍)；运行后module.exports就是{chunk1:1}。所以当我们使用chunk1这个模块的时候（比如var chunk1=require(“chunk1”),得到的就是一个对象{chunk1:1}）。如果模块里没有exports.chunk1=chunk1或者module.exports=chunk1得到的就是一个空对象{}2.使用模块上面我们已经分析了webpack是怎么打包一个模块的（入口文件就是一个模块），现在我们来看一下使用一个模块，然后使用模块的文件作为入口文件webpack.config.js1234567module.exports = &#123; entry:\"./main.js\", output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;&#125;;main.js12var chunk1=require(\"./chunk1\");console.log(chunk1);打包后123456789101112131415161718192021222324252627282930313233343536(function (modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if (installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = \"\"; // Load entry module and return exports return __webpack_require__(0);&#125;)([function (module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); console.log(chunk1);&#125;, function (module, exports) &#123; var chunk1 = 1; exports.chunk1 = chunk1;&#125;]);不一样的地方就是自执行函数的参数由1[function(module, exports) &#123; var chunk1=1; exports.chunk1=chunk1;&#125;]变为1234567[function (module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); console.log(chunk1);&#125;, function (module, exports) &#123; var chunk1 = 1; exports.chunk1 = chunk1;&#125;]其实就是多了一个main模块，不过这个模块没有导出项，而且这个模块依赖于chunk1模块。所以当运行webpack_require(0)的时候，main模块缓存到installedModules[0]上，modules[0].call(也就是调用main模块)的时候，chunk1被缓存到installedModules[1]上，并且导出对象{chunk1：1}给模块main使用3.重复使用模块webpack.config.js1234567module.exports = &#123; entry:\"./main.js\", output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;&#125;;main.js1234var chunk1=require(\"./chunk1\");var chunk2=require(\".chunlk2\");console.log(chunk1);console.log(chunk2);chunk1.js123var chunk2=require(\"./chunk2\");var chunk1=1;exports.chunk1=chunk1;chunk2.js12var chunk2=1;exports.chunk2=chunk2;打包后123456789101112131415161718192021222324252627282930313233343536373839404142434445(function (modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if (installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = \"\"; // Load entry module and return exports return __webpack_require__(0);&#125;)([function (module, exports, __webpack_require__) &#123; var chunk1 = __webpack_require__(1); var chunk2 = __webpack_require__(2); console.log(chunk1); console.log(chunk2);&#125;, function (module, exports, __webpack_require__) &#123; __webpack_require__(2); var chunk1 = 1; exports.chunk1 = chunk1;&#125;, function (module, exports) &#123; var chunk2 = 1; exports.chunk2 = chunk2;&#125;]);不难发现，当需要重复使用模块的时候，缓存变量installedModules 就起作用了4.多个打包入口不管是单一模块还是重复模块，和以上两种一样5.入口参数为数组webpack.config.js1234567module.exports = &#123; entry:['./main.js','./main1.js'], output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;&#125;;打包后123456789101112131415161718192021[/* 0 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); module.exports = __webpack_require__(3);/***/ &#125;,/* 1 *//***/ function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(2); console.log(chunk1);/***/ &#125;,/* 2 *//***/ function(module, exports) &#123; var chunk1=1; exports.chunk1=chunk1;/***/ &#125;,/* 3 *//***/ function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(2);/***/ &#125;/******/ ]这里只截取自执行匿名函数的参数，因为其他代码与之前一样。可以看到1就是main默模块，2就是chunk1模块，3就是mian1模块，0的作用就是运行模块mian,mian1,然后将main1模块导出（main1中没有导出项，所以到导出{}），总结一下：入口参数是字符串不管是多入口还是单入口，最后都会将入口模块的导出项导出,没有导出项就导出{}，而入口参数是数组，就会将最后一个模块导出（webpackg官网有说明）6.使用CommonsChunkPlugin插件webpack.config.js12345678910111213141516var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', &#125;, output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: \"common\" &#125;) ]&#125;;main mian1中都require了chunk1,所以chunk1会被打包到common。打包后，common.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283(function (modules) &#123; // webpackBootstrap // install a JSONP callback for chunk loading var parentJsonpFunction = window[\"webpackJsonp\"]; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) &#123; // add \"moreModules\" to the modules object, // then flag all \"chunkIds\" as loaded and fire callback var moduleId, chunkId, i = 0, callbacks = []; for (; i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i]; if (installedChunks[chunkId]) callbacks.push.apply(callbacks, installedChunks[chunkId]); installedChunks[chunkId] = 0; &#125; for (moduleId in moreModules) &#123; modules[moduleId] = moreModules[moduleId]; &#125; if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules); while (callbacks.length) callbacks.shift().call(null, __webpack_require__); if (moreModules[0]) &#123; installedModules[0] = 0; return __webpack_require__(0); &#125; &#125;; // The module cache var installedModules = &#123;&#125;; // object to store loaded and loading chunks // \"0\" means \"already loaded\" // Array means \"loading\", array contains callbacks var installedChunks = &#123; 2: 0 &#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if (installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; // This file contains only the entry chunk. // The chunk loading function for additional chunks __webpack_require__.e = function requireEnsure(chunkId, callback) &#123; // \"0\" is the signal for \"already loaded\" if (installedChunks[chunkId] === 0) return callback.call(null, __webpack_require__); // an array means \"currently loading\". if (installedChunks[chunkId] !== undefined) &#123; installedChunks[chunkId].push(callback); &#125; else &#123; // start chunk loading installedChunks[chunkId] = [callback]; var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.src = __webpack_require__.p + \"\" + chunkId + \".\" + (&#123; \"0\": \"main\", \"1\": \"main1\" &#125;[chunkId] || chunkId) + \".js\"; head.appendChild(script); &#125; &#125;; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = \"\";&#125;)([, function (module, exports) &#123; var chunk1 = 1; exports.chunk1 = chunk1;&#125;]);main.js12345webpackJsonp([0],[function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); console.log(chunk1); &#125;]);main1.js1234webpackJsonp([1],[function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); console.log(chunk1);&#125;]);与之前相比，多了webpackJsonp函数，立即执行的匿名函数没有立即调用webpack_require(0)。看一下webpackJsonp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var parentJsonpFunction = window[\"webpackJsonp\"]; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) &#123; //moreModules为独立chunk代码，chunkIds标记独立chunk唯一性避免按需加载时重复加载 //以main.js中代码为例，chunkIds为[0],moreModules为 //[function(module, exports, __webpack_require__) &#123; // var chunk1=__webpack_require__(1); // console.log(chunk1); //&#125;] var moduleId, chunkId, i = 0, callbacks = []; for (; i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i];//chunkId=0 if (installedChunks[chunkId]) callbacks.push.apply(callbacks,installedChunks[chunkId]);//0 push入callbacks(使用requireEnsure不再是0) //赋值为0表明chunk已经loaded installedChunks[chunkId] = 0; &#125; for (moduleId in moreModules) &#123; //modules[0]会被覆盖 modules[moduleId] = moreModules[moduleId]; &#125; //按当前情况parentJsonpFunction一直未undefined if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules); //按当前情况callbacks=[] while (callbacks.length) callbacks.shift().call(null, __webpack_require__); if (moreModules[0]) &#123; installedModules[0] = 0; return __webpack_require__(0); &#125; &#125;; // 缓存模块，通过闭包引用(window[\"webpackJsonp\"]可以访问到) var installedModules = &#123;&#125;; //2为公共chunck唯一ID，0表示已经loaded var installedChunks = &#123; 2: 0 &#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if (installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; //按需加载 __webpack_require__.e = function requireEnsure(chunkId, callback) &#123; // \"0\" is the signal for \"already loaded\" if (installedChunks[chunkId] === 0) return callback.call(null, __webpack_require__); // an array means \"currently loading\". if (installedChunks[chunkId] !== undefined) &#123; installedChunks[chunkId].push(callback); &#125; else &#123; // start chunk loading installedChunks[chunkId] = [callback]; var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); script.type = 'text/javascript'; script.charset = 'utf-8'; script.async = true; script.src = __webpack_require__.p + \"\" + chunkId + \".\" + (&#123; \"0\": \"main\", \"1\": \"main1\" &#125;[chunkId] || chunkId) + \".js\"; head.appendChild(script); &#125; &#125;;好像看不出什么。。。，修改一下webpack.config.js12345678910111213141516171819var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', chunk1:[\"./chunk1\"] &#125;, output: &#123; path: __dirname + '/dist2', filename: '[name].js' &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: [\"chunk1\"], filename:\"common.js\", minChunks:3, &#125;) ]&#125;;main,main1都分别require chunk1,chunk2,然后将chunk1打包到公共模块（minChunks:3，chunk2不会被打包到公共模块）。自运行匿名函数最后多了1return __webpack_require__(0);则installedModules[0]为已经loaded,看common.js，installedModules[1]也会loaded。main.js123456789101112webpackJsonp([1], [function (module, exports, __webpack_require__) &#123; var chunk1 = __webpack_require__(1); var chunk2 = __webpack_require__(2); exports.a = 1; console.log(chunk1);&#125;, , function (module, exports) &#123; var chunk2 = 1; exports.chunk2 = chunk2;&#125;]);main1.js1234567891011webpackJsonp([2], [function (module, exports, __webpack_require__) &#123; var chunk1 = __webpack_require__(1); var chunk2 = __webpack_require__(2); exports.a = 1; console.log(chunk1);&#125;, , function (module, exports) &#123; var chunk2 = 1; exports.chunk2 = chunk2;&#125;]);common.js modules：12345678[function (module, exports, __webpack_require__) &#123; module.exports = __webpack_require__(1);&#125;, function (module, exports) &#123; var chunk1 = 1; exports.chunk1 = chunk1;&#125;]以main.js的代码为例，调用webpackJsonp，传入的参数chunkIds为[1],moreModules为1234567891011[function (module, exports, __webpack_require__) &#123; var chunk1 = __webpack_require__(1); var chunk2 = __webpack_require__(2); exports.a = 1; console.log(chunk1);&#125;, , function (module, exports) &#123; var chunk2 = 1; exports.chunk2 = chunk2;&#125;]12345678910111213141516171819202122var moduleId, chunkId, i = 0, callbacks = []; for (; i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i];//1 //false,赋值为0后还是false if (installedChunks[chunkId]) callbacks.push.apply(callbacks, installedChunks[chunkId]); installedChunks[chunkId] = 0; &#125; //三个模块 for (moduleId in moreModules) &#123; //moduleId:0,1,2 moreModules[1]为空模块，自执行函数的参数(公共模块)会被覆盖，但是参数中的相应模块已经loaded并且缓存 modules[moduleId] = moreModules[moduleId]; &#125; if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules); while (callbacks.length) callbacks.shift().call(null, __webpack_require__); if (moreModules[0]) &#123; //installedModules[0]会重新load,但是load的是moreModules[0]，因为modules[0]已经被覆盖，moreModules[0]依赖于 //modules[1]、modules[2],modules[1]已经loaded installedModules[0] = 0; return __webpack_require__(0); &#125;再看下面的情况：common.js 自执行函数参数（公共模块）（没有return webpack_require(0)）12345678910[,function(module, exports, __webpack_require__) &#123; var chunk1=1; var chunk2=__webpack_require__(2); exports.chunk1=chunk1;&#125;,function(module, exports) &#123; var chunk2=1; exports.chunk2=chunk2;&#125;]main.js1234567891011webpackJsonp([0],[/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); var chunk2=__webpack_require__(2); exports.a=1; console.log(chunk1); //main/***/ &#125;]);以main调用分析12345678910111213141516171819 var moduleId, chunkId, i = 0, callbacks = [];for(;i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i];//0 if(installedChunks[chunkId]) callbacks.push.apply(callbacks, installedChunks[chunkId]); installedChunks[chunkId] = 0;//表明唯一索引为0的chunk已经loaded&#125;for(moduleId in moreModules) &#123;//moreModules只有一个元素，所以modules[1]、modules[2]不会被覆盖 modules[moduleId] = moreModules[moduleId];&#125;if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);while(callbacks.length) callbacks.shift().call(null, __webpack_require__);if(moreModules[0]) &#123; installedModules[0] = 0;//moreModules[0]即modules[0]依赖modules[1]、即modules[2](没有被覆盖很关键) return __webpack_require__(0);&#125;还有这种打包情况：common.js不包含公共模块，即自执行函数参数为[]。main.js1234567891011121314webpackJsonp([0,1],[function(module, exports, __webpack_require__) &#123; var chunk1=__webpack_require__(1); var chunk2=__webpack_require__(2); exports.a=1; console.log(chunk1);&#125;,function(module, exports) &#123; var chunk1=1; exports.chunk1=chunk1;&#125;,function(module, exports) &#123; var chunk2=1; exports.chunk2=chunk2;&#125;]);以main调用分析12345678910111213141516171819 var moduleId, chunkId, i = 0, callbacks = [];for(;i &lt; chunkIds.length; i++) &#123; chunkId = chunkIds[i];//0,1 if(installedChunks[chunkId]) callbacks.push.apply(callbacks, installedChunks[chunkId]); installedChunks[chunkId] = 0;&#125;for(moduleId in moreModules) &#123; //moreModules全部转移到modules modules[moduleId] = moreModules[moduleId];&#125;if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);while(callbacks.length) callbacks.shift().call(null, __webpack_require__);if(moreModules[0]) &#123; //modules[0]是chunk文件运行代码 installedModules[0] = 0; return __webpack_require__(0);&#125;7.按需加载webpack.config.json123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;;main.js123456require.ensure(['./a'], function(require) &#123; var content = require('./a'); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close();&#125;);a.js1module.exports = 'Hello World';打包后bundle.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/******/ (function(modules) &#123; // webpackBootstrap/******/ // install a JSONP callback for chunk loading/******/ var parentJsonpFunction = window[\"webpackJsonp\"];/******/ window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) &#123;/******/ // add \"moreModules\" to the modules object,/******/ // then flag all \"chunkIds\" as loaded and fire callback/******/ var moduleId, chunkId, i = 0, callbacks = [];/******/ for(;i &lt; chunkIds.length; i++) &#123;/******/ chunkId = chunkIds[i];/******/ if(installedChunks[chunkId])/******/ callbacks.push.apply(callbacks, installedChunks[chunkId]);/******/ installedChunks[chunkId] = 0;/******/ &#125;/******/ for(moduleId in moreModules) &#123;/******/ modules[moduleId] = moreModules[moduleId];/******/ &#125;/******/ if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);/******/ while(callbacks.length)/******/ callbacks.shift().call(null, __webpack_require__);/******/ &#125;;/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // object to store loaded and loading chunks/******/ // \"0\" means \"already loaded\"/******/ // Array means \"loading\", array contains callbacks/******/ var installedChunks = &#123;/******/ 0:0/******/ &#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId, callback) &#123;/******/ // \"0\" is the signal for \"already loaded\"/******/ if(installedChunks[chunkId] === 0)/******/ return callback.call(null, __webpack_require__);/******/ // an array means \"currently loading\"./******/ if(installedChunks[chunkId] !== undefined) &#123;/******/ installedChunks[chunkId].push(callback);/******/ &#125; else &#123;/******/ // start chunk loading/******/ installedChunks[chunkId] = [callback];/******/ var head = document.getElementsByTagName('head')[0];/******/ var script = document.createElement('script');/******/ script.type = 'text/javascript';/******/ script.charset = 'utf-8';/******/ script.async = true;/******/ script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";/******/ head.appendChild(script);/******/ &#125;/******/ &#125;;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__.e/* nsure */(1, function(require) &#123; var content = __webpack_require__(1); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close(); &#125;);/***/ &#125;/******/ ]);1.bundle.js12345678910webpackJsonp([1],[/* 0 */,/* 1 *//***/ function(module, exports) &#123; module.exports = 'Hello World';/***/ &#125;]);和使用CommonsChunkPlugin打包的差异在于1234567891011121314151617181920212223/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId, callback) &#123;/******/ // \"0\" is the signal for \"already loaded\"/******/ if(installedChunks[chunkId] === 0)/******/ return callback.call(null, __webpack_require__);/******/ // an array means \"currently loading\"./******/ if(installedChunks[chunkId] !== undefined) &#123;/******/ installedChunks[chunkId].push(callback);/******/ &#125; else &#123;/******/ // start chunk loading/******/ installedChunks[chunkId] = [callback];/******/ var head = document.getElementsByTagName('head')[0];/******/ var script = document.createElement('script');/******/ script.type = 'text/javascript';/******/ script.charset = 'utf-8';/******/ script.async = true;/******/ script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";/******/ head.appendChild(script);/******/ &#125;/******/ &#125;;模块main的id为0，模块a的id为1。return webpack_require(0)，则加载main模块，modules[0].call(module.exports, module, module.exports, webpack_require)则调用函数12345678function(module, exports, __webpack_require__) &#123; __webpack_require__.e/* nsure */(1, function(require) &#123; var content = __webpack_require__(1); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close(); &#125;123456789101112131415161718192021222324252627282930313233343536/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId, callback) &#123; //installedChunks[1]为undefined/******/ // \"0\" is the signal for \"already loaded\"/******/ if(installedChunks[chunkId] === 0)/******/ return callback.call(null, __webpack_require__);/******/ // an array means \"currently loading\"./******/ if(installedChunks[chunkId] !== undefined) &#123;/******/ installedChunks[chunkId].push(callback);/******/ &#125; else &#123;/******/ // start chunk loading/******/ installedChunks[chunkId] = [callback];//installedChunks[1]为数组，表明currently loading/******/ var head = document.getElementsByTagName('head')[0];/******/ var script = document.createElement('script');/******/ script.type = 'text/javascript';/******/ script.charset = 'utf-8';/******/ script.async = true;/******/ script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";/******/ head.appendChild(script); //加载完后直接调用 /******/webpackJsonp([1],[ /******//* 0 */, /******//* 1 */ /******//***/ function(module, exports) &#123; /******/ /******/ module.exports = 'Hello World'; /******/ /******/ /******//***/ &#125; /******/]); /******/ &#125; /******/ &#125;; //installedChunks[1]在webpackJsonp得到调用installedChunks[1]为数组，元素为main模块的执行代码12345678910111213141516171819/******/ window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) &#123; //moreModules为模块a的代码/******/ // add \"moreModules\" to the modules object,/******/ // then flag all \"chunkIds\" as loaded and fire callback/******/ var moduleId, chunkId, i = 0, callbacks = [];/******/ for(;i &lt; chunkIds.length; i++) &#123;/******/ chunkId = chunkIds[i];/******/ if(installedChunks[chunkId])//installedChunks[0]==0,installedChunks[1]为数组/******/ callbacks.push.apply(callbacks, installedChunks[chunkId]);//callbacks为模块main执行代码，不为数组/******/ installedChunks[chunkId] = 0;//installedChunks[1]不为数组，表明已经加载/******/ &#125;/******/ for(moduleId in moreModules) &#123;/******/ modules[moduleId] = moreModules[moduleId];/******/ &#125;/******/ if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);/******/ while(callbacks.length)/******/ callbacks.shift().call(null, __webpack_require__);/******/ &#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://jaycewu.site/tags/webpack/"}]},{"title":"webpack CommonsChunkPlugin详细教程","slug":"webpack CommonsChunkPlugin详细教程","date":"2016-09-03T00:00:00.000Z","updated":"2019-05-15T16:05:35.704Z","comments":true,"path":"2016/09/03/webpack CommonsChunkPlugin详细教程/","link":"","permalink":"https://jaycewu.site/2016/09/03/webpack CommonsChunkPlugin详细教程/","excerpt":"","text":"1.demo结构：2.package.json配置：123456789101112131415161718192021&#123; \"name\": \"webpack-simple-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"webpack\": \"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"jquery\": \"^3.1.0\", \"vue\": \"^1.0.26\" &#125;, \"devDependencies\": &#123; \"css-loader\": \"^0.24.0\", \"style-loader\": \"^0.13.1\", \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.15.1\" &#125;&#125;3.多种打包情况(未使用CommonsChunkPlugin)(1)单一入口，模块单一引用webpack.config.js1234567891011121314var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', &#125;, output: &#123; path:__dirname+'/dist', filename: 'build.js' &#125;, plugins: [ ]&#125;;main.js1require(\"jquery\");demo目录下运行命令行 webpack或npm run webpackjquery模块被一起打包到build.js(2)单一入口，模块重复引用webpack.config.js不变，main.js：12require(\"./chunk1\");require(\"./chunk2\");chunk1.js:123require(\"./chunk2\");var chunk1=1;exports.chunk1=chunk1;chunk2.js:12var chunk2=1;exports.chunk2=chunk2;main.js引用了chunk1、chunk2,chunk1又引用了chunk2，打包后：build.js:123456789101112131415161718192021222324252627 ...省略webpack生成代码/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); __webpack_require__(2);/***/ &#125;,/* 1 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(2); var chunk1=1; exports.chunk1=chunk1;/***/ &#125;,/* 2 *//***/ function(module, exports) &#123; var chunk2=1; exports.chunk2=chunk2;/***/ &#125;/******/ ]);(3)多入口，模块单一引用，分文件输出webpack.config.js123456789101112131415var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', main1:'./main1.js' &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js' &#125;, plugins: [ ]&#125;;打包后文件main.js,main1.js 内容与（2）build.js一致####（4）多入口，模块单一引用，单一文件输出123456789101112131415var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', main1:'./main1.js' &#125;, output: &#123; path:__dirname+'/dist', filename: 'buid.js' &#125;, plugins: [ ]&#125;;build.js与（2）一致####（5）多入口，模块重复引用，单文件输出webpack.config.js与（4）一致main.js123require(\"./chunk1\");require(\"./chunk2\");exports.main=1;main1.js123require(\"./chunk1\");require(\"./chunk2\");require(\"./main\");报错：ERROR in ./main1.jsModule not found: Error: a dependency to an entry point is not allowed@ ./main1.js 3:0-174.使用CommonsChunkPlugin(1)单一入口，模块单一引用，分文件输出:webpack.config.js123456789101112131415161718var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js'//不使用[name]，并且插件中没有filename，这输出文件中只用chunk.js的内容， main.js的内容不知跑哪里去了 &#125;, plugins: [ new CommonsChunkPlugin(&#123; name:\"chunk\", filename:\"chunk.js\"//忽略则以name为输出文件的名字，否则以此为输出文件名字 &#125;) ]&#125;;main.js123require(\"./chunk1\");require(\"./chunk2\");require(\"jquery\");输出文件main.js chunk.js,chunk1.js,chunck2.js,jquery都被打包到main.js里，好像并没有什么卵用，但是页面上使用的时候chunk.js必须在mian.js前引用将chunk1.js,chunck2.js打包到chunk.js:webpack.config.js12345678910111213141516171819var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', chunk: [\"./chunk1\", \"./chunk2\"],//插件中name,filename必须以这个key为值 &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js'//不使用[name]，并且插件中没有filename， 这输出文件中只用chunk.js的内容，main.js的内容不知跑哪里去了 &#125;, plugins: [ new CommonsChunkPlugin(&#123; name:\"chunk\", // filename:\"chunk.js\"//忽略则以name为输出文件的名字，否则以此为输出文件名字 &#125;) ]&#125;;(1)单一入口，模块重复引用，分文件输出(单一入口CommonsChunkPlugin能否将多次引用的模块打包到公共模块呢？)：webpack.config.js1234567891011121314151617181920var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', //main1:'./main1.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js'//不使用[name]，并且插件中没有filename，这输出文件中只用chunk.js的内容，main.js的内容不知跑哪里去了 &#125;, plugins: [ new CommonsChunkPlugin(&#123; name:\"chunk\", // filename:\"chunk.js\"//忽略则以name为输出文件的名字，否则以此为输出文件名字 minChunks:2 &#125;) ]&#125;;main.js12require(\"./chunk1\");require(\"./chunk2\");chunk1.js123require(\"./chunk2\");var chunk1=1;exports.chunk1=chunk1;chunk2模块被引用了两次打包后，所有模块还是被打包到main.js中(2)多入口，模块重复引用，分文件输出（将多次引用的模块打包到公共模块）webpack.config.js1234567891011121314151617181920var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main:'./main.js', main1:'./main1.js', &#125;, output: &#123; path:__dirname+'/dist', filename: '[name].js'//不使用[name]，并且插件中没有filename， 这输出文件中只用chunk.js的内容，main.js的内容不知跑哪里去了 &#125;, plugins: [ new CommonsChunkPlugin(&#123; name:\"chunk\", // filename:\"chunk.js\"//忽略则以name为输出文件的名字，否则以此为输出文件名字 minChunks:2 &#125;) ]&#125;;main.js,main1.js里都引用chunk1,chunk2.打包后：chunk1,chunk2被打包到chunk.js,不再像3(3)chunk1,chunk2分别被打包到mian,mian1中。###5.将公共业务模块与类库或框架分开打包webpack.config.js1234567891011121314151617181920212223var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', common1: ['jquery'], common2: ['vue'] &#125;, output: &#123; path: __dirname + '/dist', filename: '[name].js'//不使用[name]，并且插件中没有filename， //这输出文件中只用chunk.js的内容，main.js的内容不知跑哪里去了 &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: [\"chunk\",\"common1\",\"common2\"],//页面上使用的时候common2 //必须最先加载 // filename:\"chunk.js\"//忽略则以name为输出文件的名字， //否则以此为输出文件名字 minChunks: 2 &#125;) ]&#125;;jquery被打包到common1.js,vue被打包到common2.js,chunk.js打包的是公共的业务模块(webpack用插件CommonsChunkPlugin进行打包的时候，将符合引用次数(minChunks)的模块打包到name参数的数组的第一个块里（chunk）,然后数组后面的块依次打包(查找entry里的key,没有找到相关的key就生成一个空的块)，最后一个块包含webpack生成的在浏览器上使用各个块的加载代码，所以页面上使用的时候最后一个块必须最先加载)将webpack.config.js改为12345678910111213141516171819202122var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', jquery:[\"jquery\"], vue:[\"vue\"] &#125;, output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: [\"common\",\"jquery\",\"vue\",\"load\"], minChunks:2 &#125;) ]&#125;;main.js1234require(\"./chunk1\");require(\"./chunk2\");var jq=require(\"jquery\");console.log(jq);main1.js12345require(\"./chunk1\");require(\"./chunk2\");var vue=require(\"vue\");console.log(vue);exports.vue=vue;打包后common.js12345678910111213141516171819webpackJsonp([4,5],[/* 0 */,/* 1 */,/* 2 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(3); var chunk1=1; exports.chunk1=chunk1;/***/ &#125;,/* 3 *//***/ function(module, exports) &#123; var chunk2=1; exports.chunk2=chunk2;/***/ &#125;]);相当于公共的业务代码都打包到了common.js里load.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/******/ (function(modules) &#123; // webpackBootstrap/******/ // install a JSONP callback for chunk loading/******/ var parentJsonpFunction = window[\"webpackJsonp\"];/******/ window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) &#123;/******/ // add \"moreModules\" to the modules object,/******/ // then flag all \"chunkIds\" as loaded and fire callback/******/ var moduleId, chunkId, i = 0, callbacks = [];/******/ for(;i &lt; chunkIds.length; i++) &#123;/******/ chunkId = chunkIds[i];/******/ if(installedChunks[chunkId])/******/ callbacks.push.apply(callbacks, installedChunks[chunkId]);/******/ installedChunks[chunkId] = 0;/******/ &#125;/******/ for(moduleId in moreModules) &#123;/******/ modules[moduleId] = moreModules[moduleId];/******/ &#125;/******/ if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);/******/ while(callbacks.length)/******/ callbacks.shift().call(null, __webpack_require__);/******/ if(moreModules[0]) &#123;/******/ installedModules[0] = 0;/******/ return __webpack_require__(0);/******/ &#125;/******/ &#125;;/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // object to store loaded and loading chunks/******/ // \"0\" means \"already loaded\"/******/ // Array means \"loading\", array contains callbacks/******/ var installedChunks = &#123;/******/ 5:0/******/ &#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId, callback) &#123;/******/ // \"0\" is the signal for \"already loaded\"/******/ if(installedChunks[chunkId] === 0)/******/ return callback.call(null, __webpack_require__);/******/ // an array means \"currently loading\"./******/ if(installedChunks[chunkId] !== undefined) &#123;/******/ installedChunks[chunkId].push(callback);/******/ &#125; else &#123;/******/ // start chunk loading/******/ installedChunks[chunkId] = [callback];/******/ var head = document.getElementsByTagName('head')[0];/******/ var script = document.createElement('script');/******/ script.type = 'text/javascript';/******/ script.charset = 'utf-8';/******/ script.async = true;/******/ script.src = __webpack_require__.p + \"\" + chunkId + \".\" + (&#123;\"0\":\"jquery\",\"1\":\"main\",\"2\":\"main1\",\"3\":\"vue\",\"4\":\"common\"&#125;[chunkId]||chunkId) + \".js\";/******/ head.appendChild(script);/******/ &#125;/******/ &#125;;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ &#125;)/************************************************************************//******/ ([]);使用的时候必须最先加载load.js6.参数minChunks: Infinity看一下下面的配置会是什么结果123456789101112131415161718192021var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', jquery:[\"jquery\"] &#125;, output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: \"jquery\", minChunks:2 &#125;) ]&#125;;main.js,main1.js共同引用的chunk1和chunk2会被打包到jquery.js里minChunks:2修改为minChunks:Infinity后，chunk1和chunk2都打包到main.js,main1.js里7.参数chunkswebpack.config.js1234567891011121314151617181920212223var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");module.exports = &#123; entry: &#123; main: './main.js', main1: './main1.js', jquery:[\"jquery\"] &#125;, output: &#123; path: __dirname + '/dist', filename: '[name].js' &#125;, plugins: [ new CommonsChunkPlugin(&#123; name: \"jquery\", minChunks:2, chunks:[\"main\",\"main1\"] &#125;) ]&#125;;只有在main.js和main1.js中都引用的模块才会被打包的到公共模块（这里即jquery.js）","categories":[{"name":"前端","slug":"前端","permalink":"https://jaycewu.site/categories/前端/"}],"tags":[{"name":"CommonsChunkPlugin","slug":"CommonsChunkPlugin","permalink":"https://jaycewu.site/tags/CommonsChunkPlugin/"}]},{"title":"C# 泛型","slug":"泛型","date":"2015-10-20T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2015/10/20/泛型/","link":"","permalink":"https://jaycewu.site/2015/10/20/泛型/","excerpt":"","text":"泛型类，泛型方法，泛型属性1234567891011121314public class MyClass&lt;T&gt; &#123; //指定MyMethod方法用以执行类型为X的参数 public void MyMethod&lt;X&gt;(X x) &#123; // &#125; //此方法也可不指定方法参数 public void MyMethod&lt;X&gt;() &#123; // &#125; &#125;MyClass是一个泛型类。即使类不是泛型类，也可以定义泛型方法1234567891011121314public class MyClass &#123; //指定MyMethod方法用以执行类型为X的参数 public void MyMethod&lt;X&gt;(X x) &#123; // &#125; //此方法也可不指定方法参数 public void MyMethod&lt;X&gt;() &#123; // &#125; &#125;属性不能指定自己的泛型参数，它们只能使用所属类中定义的泛型参数进行操作。1234public class MyClass&lt;T&gt; &#123; private T _tValue; &#125;泛型类的实例化1var myClass=new MyClass&lt;int&gt;();在调用泛型方法的时候，可以提供要在调用场所使用的类型123 //调用泛型方法MyClass myClass = new MyClass();myClass.MyMethod&lt;int&gt;(3);在调用泛型方法时，C#编译器足够聪明，基于传入的参数类型来推断出正确的类型123 //泛型推理机制调用泛型方法MyClass myClass = new MyClass();myClass.MyMethod(3);泛型方法无法只根据返回值的类型推断出类型12345public static T GetValue&lt;T&gt;() &#123; T a =default(T); return a; &#125;12GetValue&lt;int&gt;();GetValue();//报错泛型约束T：struct类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。T：class类型参数必须是引用类型，包括任何类、接口、委托或数组类型。T：new()类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。T：&lt;基类名&gt;类型参数必须是指定的基类或派生自指定的基类。T：&lt;接口名称&gt;类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。T：U为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束。泛型方法中泛型参数的约束1234public T GetTValue&lt;T&gt;(T t)where T:IList &#123; return t; &#125;类型T必须是IList类型的1GetTValue(new List&lt;int&gt;()&#123;1212&#125;)无法为类级别的泛型参数提供方法级别的约束12345678public class MyClass&lt;T&gt; &#123; public void MyMethod&lt;X&gt;(X x,T t) where X:IComparable&lt;X&gt; where T:IComparer&lt;T&gt; &#123; // &#125; &#125;类实例化的时候，T类型已经确定，方法处无法再进行约束，正确的方法12345678public class MyClass&lt;T&gt; where T:IComparable&lt;T&gt; &#123; public void MyMethod&lt;X&gt;(X x,T t) where X:IComparable&lt;X&gt; &#123; // &#125; &#125;泛型参数虚方法的重写:子类方法必须重新定义该方法特定的泛型参数1234567891011121314public class MyBaseClass &#123; public virtual void SomeMethod&lt;T&gt;(T t) &#123; // &#125; &#125; public class MyClass :MyBaseClass &#123; public override void SomeMethod&lt;X&gt;(X x) &#123; &#125; &#125;同时子类中的泛型方法不能重复基类泛型方法的约束123456789101112131415161718192021public class MyBaseClass &#123; public virtual void SomeMethod&lt;T&gt;(T t) where T:new() &#123; // &#125; &#125; public class MyClass :MyBaseClass &#123; //正确写法 public override void SomeMethod&lt;X&gt;(X x) &#123; &#125; ////错误 重写和显式接口实现方法的约束是从基方法继承的，因此不能直接指定这些约束 //public override void SomeMethod&lt;X&gt;(X x) where X:new() //&#123; //&#125; &#125;类中定义的委托可以使用该类的泛型参数12345678public class MyClass&lt;T&gt; &#123; public delegate void GenericDelegate(T t); public void SomeMethod(T t) &#123; &#125; &#125;用作约束的泛型类型参数称为裸类型约束1234class List&lt;T&gt;&#123;void Add&lt;U&gt;(List&lt;U&gt; items) where U : T &#123;/*...*/&#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://jaycewu.site/tags/C/"},{"name":"泛型","slug":"泛型","permalink":"https://jaycewu.site/tags/泛型/"}]},{"title":"c# 委托与事件","slug":"委托与事件","date":"2015-10-16T00:00:00.000Z","updated":"2019-05-15T16:05:35.708Z","comments":true,"path":"2015/10/16/委托与事件/","link":"","permalink":"https://jaycewu.site/2015/10/16/委托与事件/","excerpt":"","text":"委托是什么？（1） 从数据结构来讲，委托是和类一样是一种用户自定义类型。（2） 从设计模式来讲，委托（类）提供了方法（对象）的抽象。既然委托是一种类型，那么它存储的是什么数据？我们知道，委托是方法的抽象，它存储的就是一系列具有相同签名和返回回类型的方法的地址。调用委托的时候，委托包含的所有方法将被执行。委托类型的定义委托是类型，就好像类是类型一样。与类一样，委托类型必须在被用来创建变量以及类型对象之前声明。delegate void MyDel(int x);委托类型声明：（1） 以deleagate关键字开头。（2）返回类型+委托类型名+参数列表。3. 声明委托变量MyDel del1,del2;初始化委托变量(1) 使用new运算符new运算符的操作数的组成如下：12del1 = new MyDel( myInstObj.MyM1 );del2 = new MyDel( SClass.OtherM2 );方法可以是实例方法或静态方法(2)使用快捷语法快键语法，它仅由方法说明符构成。之所以能这样，是因为在方法名称和其相应的委托类型之间有隐式转换。12del1 = myInstObj.MyM1;del2 = SClass.OtherM2;赋值委托由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的方法地址引用。旧的引用会被垃圾回收器回收。123MyDel del;del = myInstaObj.MyM1; //委托初始化del = SClass.OtherM2;//委托重新赋值，旧的引用将被回收组合委托委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。委托是恒定的，操作数委托创建后不会被改变。委托组合拷贝的是操作数的副本。123MyDel del1 = myObj.MyMethod;MyDel del2 = SClass.OtherM2;MyDel del3 = del1 + del2; //组合调用列表委托加减运算可以使用+=运算符，为委托新增方法。同样可以使用-=运算符，为委托移除方法。123MyDel del = myObj.MyMethod;del += SClass.OtherM2; // 增加方法del -= myObj.MyMethod; // 移除方法委托调用委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。在调用委托前，应判断委托是否为空。调用空委托会抛出异常。1234if(null != del)&#123; del();//委托调用&#125;匿名方法匿名方法是在初始化委托时内联声明的方法。基本结构：1deleage( 参数 ) &#123; 语句块 &#125;例如：123delegate int MyDel (int x); //定义一个委托MyDel del = delegate( int x)&#123; return x; &#125;;从上面我们可以看到，匿名方法是不会显示声明返回值的。Lambda表达式Lambda表达式主要用来简化匿名方法的语法。在匿名方法中，delegate关键字有点多余，因为编译器已经知道我们将方法赋值给委托。通过几个简单步骤，我们就可以将匿名方法转换为Lambda表达式：123MyDel del = delegate( int x) &#123; return x; &#125;;//匿名方法MyDel del2 = (int x) =&gt; &#123;return x;&#125;;//Lambda表达式MyDel del3 = x =&gt; &#123;return x&#125;;//简写的Lambda表达式简单使用123456789101112131415161718192021222324class Program &#123; private delegate void MyDel(string text); static void Main(string[] args) &#123; MyDel myDel=ConsoleWriteTest; myDel(\"1\");//调用委托 DelegateParaTest(\"2\",myDel);//委托作为参数 DelegateParaTest(\"3\",ConsoleWriteTest);//方法隐式转换为委托 DelegateParaTest(\"4\",x=&gt;Console.WriteLine(x)); Console.ReadLine(); &#125; private static void ConsoleWriteTest(string text) &#123; Console.WriteLine(text); &#125; private static void DelegateParaTest(string text,MyDel mydel) &#123; mydel(text); &#125; &#125;注意使用new初始化委托的时候必须包含参数，参数可以是委托实例，方法，Lambda表达式。委托是和类一样是一种用户自定义类型:delegate void MyDel(int x);很容易把委托MyDel当成一个方法或者属性。private MyDel _myDel;这才是一个委托类型的属性一个委托类型作为类属性的时候，使用+=之前不用进行初始化(不用new或者=进行赋值),但是作为方法内一个变量的时候，必须进行初始化。123456789101112private delegate void MyDel(string text);private static MyDel _myDel;static void Main(string[] args)&#123; _myDel += Console.WriteLine; _myDel(\"233\"); //MyDel myDel = Console.WriteLine;//报错 MyDel myDel = Console.WriteLine; myDel(\"666\"); Console.ReadLine();&#125;事件1234567891011121314public delegate void MyDel(string text);class MyClass&#123; public MyDel MyDel; public void InvokeMyDel(string text) &#123; if (MyDel != null) &#123; MyDel(text); &#125; &#125;&#125;类中有一个委托类型的属性。可以这样使用1234MyClass myClass=new MyClass();myClass.MyDel = Console.WriteLine;myClass.InvokeMyDel(\"1\"); myClass.myDel(\"1\");//也可以直接调用，但是调用之前判断是否为null可以为委托增加多个方法1234MyClass myClass=new MyClass();myClass.MyDel = Console.WriteLine;myClass.MyDel += Console.WriteLine;myClass.InvokeMyDel(\"1\");因为要在委托上增加方法，声明为public，但是如果一不小心使用了=进行重新赋值(特别是当委托属性是static的时候)，就会造成意向不到的结果。为了避免这一情况，使用private修饰委托属性，公开一个方法在委托属性上增加方法。1234567891011121314151617181920class MyClass &#123; public delegate void MyDel(string text); private MyDel myDel; public void InvokeMyDel(string text) &#123; if (myDel != null) &#123; myDel(text); &#125; &#125; public void AddMethod(MyDel method) &#123; myDel += method; &#125; &#125;事件是一种特殊的委托的实例，或者说是受限制的委托，是委托一种特殊应用，在类的外部只能施加+=,-=操作符，二者本质上是一个东西。event MyDel _myDel; // 编译成创建一个私有的委托示例, 和施加在其上的add, remove方法.event只允许用add, remove方法来操作，这导致了它不允许在类的外部被直接触发，只能在类的内部适合的时机触发。委托可以在外部被触发，但是别这么用。使用中，委托常用来表达回调，事件表达外发的接口。委托和事件支持静态方法和成员方法, delegate(void * pthis, f_ptr), 支持静态返方法时, pthis传null.支持成员方法时, pthis传被通知的对象.委托对象里的三个重要字段是, pthis, f_ptr, pnext, 也就是被通知对象引用, 函数指针/地址, 委托链表的下一个委托节点.12private MyDel _myDel;//委托private event MyDel _myDel;//事件事件不能在类的外部直接调用，只能通过暴露的方法进行间接触发。","categories":[{"name":"后端","slug":"后端","permalink":"https://jaycewu.site/categories/后端/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://jaycewu.site/tags/C/"},{"name":"委托","slug":"委托","permalink":"https://jaycewu.site/tags/委托/"},{"name":"事件","slug":"事件","permalink":"https://jaycewu.site/tags/事件/"}]}]}